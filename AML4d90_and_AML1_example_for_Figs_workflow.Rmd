---
title: "20250130_AML4d90_and_AML1_example_for_Figs_workflow"
author: "Sami B. Kanaan"
date: "7/24/2025"
output: html_document
editor_options: 
  chunk_output_type: console
---

---
### SETTING UP ENVIRONMENT ###

```{r}
graphics.off()
rm(list=ls())
knitr::opts_chunk$set(fig.width=8, fig.height=6,dpi=300,
                      echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(dev.args=list(bg="transparent"))
ROOT_DIR<-"/fh/fast/furlan_s/user/skanaan/scrHLAtyping"
stem<-"/WorkFlowTest_AML401/_R_ANALYSES"
DATA_DIR <- file.path(ROOT_DIR, stem, "data")   
RES_DIR  <- file.path(ROOT_DIR,  stem, "res")   
RMD_DIR  <- file.path(ROOT_DIR, stem, "rmd")     
CDS_DIR <- file.path(ROOT_DIR, stem, "cds")
FIG_DIR <- file.path(ROOT_DIR,  stem, "figs")

## if you haven't already:
remotes::install_github("https://github.com/furlan-lab/scrHLAmatrix", upgrade = "never", auth_token="<until_scrHLAmatrix_becomes_public,_use_your_token_here>")
## make sure leiden and its python dependencies are installed:
# reticulate::install_python(version = '<version>') #example '3.8.2'
# reticulate::py_install('python-igraph')
# reticulate::py_install('leidenalg', forge = TRUE)
# reticulate::py_config()

suppressPackageStartupMessages({
  library(stringr)
  library(pbmcapply)
  library(parallel)
  library(Matrix)
  library(magrittr)
  library(htmltools)
  library(ggplot2)
  library(Seurat)
  library(dplyr)
  library(cowplot)
  library(Biostrings)
  library(data.table)
  library(IRanges)
  library(S4Vectors)
  library(uwot)
  library(gridExtra)
  library(tidyr)
  library(viridis)
  library(crayon)
  library(reticulate)
  library(viewmastR)
  library(scCustomize)
  library(Polychrome)
  library(ggh4x)
  library(muscat)
  # library(ComplexHeatmap)
  # library(scrubletR)
  library(scrHLAmatrix)
})
packageVersion("scrHLAmatrix")

## color palette
bmcolsl <- viewmastR::sfc(16)[c(1:3, 5:16)]
names(bmcolsl)<-c("01_HSC", "02_Early_Erythroid","03_Late_Erythroid","04_Myeloid_Progenitor","05_Lymphoid_Progenitor","06_pDC","07_cDC","08_CD14_Monocyte","09_CD16_Monocyte","10_Other","11_Pre_B","12_B", "13_Plasma","14_T" ,"15_NK")

```

## Fig.1 and Suppl.Fig.S5 
# Building the method with samples from AML1 with 5' and 3' captures

```{r}
#------ Fig.1a, 1b ------#
## art done separately

#------ Fig.1c left panel ------#
## 1st iteration of scrHLAtag
dirs_path <- "/fh/fast/furlan_s/grp/data/targ_reseq/01_scrHLA_project/221128_PB__AtoD_EWS__EtoG_HLA__H_NUP98_TSOdepl/5_E01" # 5' files
# dirs_path <- "/fh/fast/furlan_s/grp/data/targ_reseq/01_scrHLA_project/231020_longreadTSO_HLA_MDS_DB_LA_MO_EWS/3_C01"      # 3' files
dirs<-list.dirs(path=dirs_path, full.names = T, recursive = F)
dirs<- lapply(dirs, dir, pattern = "^unguid", recursive = F, full.names = T) %>% unlist
dirnames <- c("AML_F_5", "AML_E_5", "AML401_BM", "AML401_34")               # this is how the 5' samples were organized in the directories
# dirnames <- c("Pre_Ifng_4", "Post_Ifng_4", "AML_E_3", "MO1_IP_1") # this is how the 3' samples were organized in the directories

## Load Seurat
## Note: you can reconstruct any Seurat object from the barcodes.tsv, metadata.csv, features.tsv, and matrix.mtx files available in GEO

## if 5' rds
seu<-readRDS(file.path("/fh/fast/furlan_s/user/skanaan/scrHLAtyping/_R_ANALYSES/221128_PB__AtoD_EWS__EtoG_HLA__H_NUP98_TSOdepl/cds",
                       "221010_AML101_addmutations.RDS"))

# ## if 3' rds
# seu<-readRDS(file.path("/fh/fast/furlan_s/user/skanaan/scrHLAtyping/_R_ANALYSES/231020_longreadTSO_HLA_MDS_DB_LA_MO_EWS/cds",
#                        "220919_seuratObj_AML101_celltype_genotype.RDS"))
# seu <- seu[,which(seu$dataset == "34_enrich")] # only the CD34+ fraction was HLA enriched

## Load the counts files
cts <- HLA_load(directories = dirs, dir_names = dirnames, cell_data_obj = seu)

## Visualize
plot_top_alleles <- Top_HLA_plot_bulk(reads_1 = cts[["mRNA"]], 
                                      reads_2 = cts[["gene"]], 
                                      #cluster_index = 1,       # 1 then 2 for the other HLA cluster
                                      use_alt_align_ABC = T,    # alternative align for ABC is TRUE for 1st iteration
                                      min_reads_per_gene = 20)  # plotting on the mRNA as primary gives better results overall
plot_top_alleles # for best visuals: 12 x 8 in

#------ Fig.1c right panel ------#
## final iteration of scrHLAtag
dirs_path <- "/fh/fast/furlan_s/grp/data/targ_reseq/01_scrHLA_project/221128_PB__AtoD_EWS__EtoG_HLA__H_NUP98_TSOdepl/5_E01" # 5' files
# dirs_path <- "/fh/fast/furlan_s/grp/data/targ_reseq/01_scrHLA_project/231020_longreadTSO_HLA_MDS_DB_LA_MO_EWS/3_C01" # 3' files
dirs<-list.dirs(path=dirs_path, full.names = T, recursive = F)
dirs<- lapply(dirs, dir, pattern = "^guided4", recursive = F, full.names = T) %>% unlist
dirnames <- c("AML_F_5", "AML_E_5", "AML401_BM", "AML401_34") # this is how the 5' samples were organized in the directories
# dirnames <- c("Pre_Ifng_4", "Post_Ifng_4", "AML_E_3", "MO1_IP_1") # this is how the 3' samples were organized in the directories

## Load the counts files
cts <- HLA_load(directories = dirs, dir_names = dirnames, cell_data_obj = seu)

## Visualize
top_per_CB <- Top_HLA_plot_byCB(reads = cts[["mRNA"]],
                                 cell_data_obj = seu,
                                 hla_with_counts_above = 0,
                                 CBs_with_counts_above = 0,
                                 # cluster_index = 1, # 1 then 2 for the other HLA cluster
                                 return_genotype_data = T, 
                                 parallelize = T)
top_per_CB[[1]] %>% grid.arrange() # for best visuals: 16 x 8 in

#------ Fig.1d ------#
## souporcell and viewmaster data have been previously calculated as described 
## in https://furlan-lab.github.io/viewmastR/
## and stored in the 'geno' and 'celltype' metadata columns of the 
## Seurat object (see also the "Seurat_Assemble" example workflow)
DimPlot_scCustom(seu, group.by = "celltype", colors_use = bmcolsl, pt.size = 0.4)
DimPlot_scCustom(seu, group.by = "geno", label = F, pt.size = 0.1,order = sort(unique(seu$geno), decreasing = T))+scale_color_manual(values=c("grey65", "red"))

#------ Fig.1e, Suppl.Fig.S5 ------#
## if you have an idea of what might be the donor specific and recipient specific alleles 
## (if not run HLA_Matrix() without, and see if you can guess)
rp <- c("DMA*01:02:01")
dn <- c("DMB*01:03:01")

## Run HLA_Matrix() 
hla <- HLA_Matrix(reads = cts[["mRNA"]], cell_data_obj = seu, 
                  CB_rev_com = F,    # TRUE for 3prime 10x on pacbio
                  hla_recip = rp,
                  hla_donor = dn,
                  return_stats = F,
                  parallelize = F)
HLA.assay <- CreateAssayObject(counts = hla)
# map the alleles into seurat
suppressWarnings(seu@assays$HLA <- HLA.assay)
# normalize
DefaultAssay(seu) <- "HLA"
seu <- NormalizeData(seu, normalization.method = "LogNormalize", scale.factor = 100)
FeatP <- c()
for (i in 1:length(row.names(seu))) {
  g <- FeaturePlot_scCustom(seu, row.names(seu)[i], pt.size = 0.1)+
    theme(legend.position = "none", axis.line = element_blank(), 
          axis.text = element_blank(), axis.ticks = element_blank(), 
          axis.title = element_blank(), plot.title = element_text(size = 10))
  FeatP<- c(FeatP,list(g))
}
do.call("plot_grid", c(FeatP, align = "hv", ncol=floor(sqrt(length(FeatP))))) # for best visuals: 18 x 15 in

## Organize in a table the alleles of each HLA gene

#------ Fig.1f ------#
Idents(seu)
Idents(seu)<-seu$geno
levels(Idents(seu))
hla_rp <- gsub("[_*|?.+$^]", "-", rp)
hla_dn <- gsub("[_*|?.+$^]", "-", dn)
{
  genotype0 <- seu@assays$HLA@counts[,Idents(seu)== levels(Idents(seu))[1]] 
  genotype1 <- seu@assays$HLA@counts[,Idents(seu)== levels(Idents(seu))[2]] 
  pr_in0 <- data.frame( 
    "col1" = apply(genotype0 > 0, MARGIN = 1, FUN = 'sum') / 
      (apply(genotype0 == 0, MARGIN = 1, FUN = 'sum') + apply(genotype0 > 0, MARGIN = 1, FUN = 'sum'))
  )
  colnames(pr_in0) <- paste0("frac_", levels(Idents(seu))[1])
  pr_in1<- data.frame( 
    "col1" = apply(genotype1 > 0, MARGIN = 1, FUN = 'sum') / 
      (apply(genotype1 == 0, MARGIN = 1, FUN = 'sum') + apply(genotype1 > 0, MARGIN = 1, FUN = 'sum'))
  )
  colnames(pr_in1) <- paste0("frac_", levels(Idents(seu))[2])
  pr_exp <- as.data.frame(cbind(pr_in0, pr_in1))
  rm(pr_in0, pr_in1, genotype0, genotype1)
  pr_exp$AlleleOrigin <- ifelse(rownames(pr_exp) %in% hla_rp, "recipient", ifelse(rownames(pr_exp) %in% hla_dn, "donor", "shared"))
  pr_exp$Ct <- 0
  pr_exp <- pr_exp[order(row.names(pr_exp)),]
  pr_exp <- pr_exp[order(pr_exp$AlleleOrigin),]
  pr_exp$Alleles <- rownames(pr_exp)
  rownames(pr_exp) <- NULL
  pr0 <- pr_exp[,c(1, 3:5)]
  pr0$souporcell_geno <- levels(Idents(seu))[1]
  names(pr0)[names(pr0) == paste0("frac_", levels(Idents(seu))[1])] <- "Proportions"
  pr1 <- pr_exp[,c(2, 3:5)]
  pr1$souporcell_geno <- levels(Idents(seu))[2]
  names(pr1)[names(pr1) == paste0("frac_", levels(Idents(seu))[2])] <- "Proportions"
  pr_expgg <- rbind(pr0,pr1)
  rm(pr0,pr1)
}
ggplot(pr_expgg, aes(x= as.factor(souporcell_geno), y= Proportions, fill = as.factor(souporcell_geno)))+
  geom_bar(stat="identity", position=position_dodge(), alpha= 1, linetype = 0) +
  # scale_y_continuous(name= "Proportion of Cells expressing Allele (pseudo log scale)",
  #                    trans = scales::pseudo_log_trans(0.0001, 10),
  #                    breaks=c(0, 0.001, 0.01, 0.1, 1, 10))+
  scale_y_continuous(name= "Proportion of Cells expressing Allele")+
  # annotation_logticks(sides = "l", outside = F, short = unit(0.75,"mm"), mid = unit(0.75,"mm"), long = unit(1.5,"mm"), size = 0.25)+
  # coord_fixed(ratio= 1, ylim = c(0.0001, 1), xlim = c(0.15, 100))+
  labs(x= "Souporcell Geno", fill= "Souporcell Geno")+
  scale_fill_manual(values = c("grey65", "red"))+
  facet_wrap(AlleleOrigin ~ Alleles)+
  ggthemes::theme_clean()+ 
  #theme_cowplot()+
  theme(legend.position="top", legend.direction = "horizontal", strip.text.x = element_text(margin = margin(.5,0,.5,0, "mm"))) # recommended for visualization: 10 x 12 in

```

## Fig.2 and Suppl.Fig.S8
# Quantifying HLA in longitudinally followed-up AML4
# Agreement with souporcell
# read numbers Iso-Seq vs. MAS-seq

```{r}
## You can reconstruct any Seurat object from the barcodes.tsv, metadata.csv, features.tsv, and matrix.mtx files available in GEO
expr_matrix <- readMM(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_RNA_matrix.mtx.gz"))
rownames(expr_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_RNA_features.tsv.gz"), header=F)$V1
colnames(expr_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_barcodes.tsv.gz"), header=F)$V1
metadata <- data.frame(fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_metadata.csv"), header=T), row.names=1)
seu <- CreateSeuratObject(counts = expr_matrix, project = "AML4_d90")
#make sure the metadata barcodes are the same as the seu barcodes
identical(metadata, metadata[colnames(seu), , drop = F])
seu <- AddMetaData(seu, metadata)
#add ADT
adt_matrix <- readMM(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_ADT_matrix.mtx.gz"))
rownames(adt_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_ADT_features.tsv.gz"), header=F)$V1
colnames(adt_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_barcodes.tsv.gz"), header=F)$V1
seu@assays$ADT <- CreateAssayObject(counts = adt_matrix)
#add the already saved HLAMAS-seq assay (the regular HLA assay will be generated below, for the sake of the example)
mas_matrix <- readMM(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_HLAMAS_matrix.mtx.gz"))
rownames(mas_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_HLAMAS_features.tsv.gz"), header=F)$V1
colnames(mas_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_barcodes.tsv.gz"), header=F)$V1
seu@assays$HLAMAS <- CreateAssayObject(counts = mas_matrix)
#if UMAP backed up in metadata, use them:
umap_df <- data.frame(seu$UMAP_1_backup, seu$UMAP_2_backup)
colnames(umap_df) <- c(1,2)
seu@reductions$umap <- CreateDimReducObject(embeddings = as.matrix(umap_df), key = "umap_")
rm(expr_matrix, metadata, umap_df, adt_matrix, mas_matrix)

samples<-unique(sapply(colnames(seu), function(i){
  i<-strsplit(i, "_")
  paste(i[[1]][1:length(i[[1]])-1], collapse = "_")  
}))

## Match the patient names with their respective count data directories
dirs_path <- "/fh/fast/furlan_s/user/skanaan/scrHLAtyping/WorkFlowTest_AML401/pacbio_isoseq_scrHLAtag_out"
dirs<-list.dirs(path=dirs_path, full.names = T, recursive = F)
dirs<- lapply(dirs, list.dirs, recursive = F) %>% unlist
dirs<- lapply(dirs, dir, pattern = "^guid", recursive = F, full.names = T) %>% unlist
dirnames <- c("AML401_BM", "AML401_34") # this is how the samples were organized in the directories

## Load the counts files
cts <- HLA_load(directories = dirs, dir_names = dirnames, cell_data_obj = seu)

## define the recipient-specific and donor-specific HLA alleles if known. For example:
rp = c("A*24:02:01", "B*48:01:01", "C*08:06", "DMA*01:02:01", "DPA1*01:03:01", "DPB1*04:02:01", "DQA1*03:03:01", "DQB1*03:01:01", "DRA*01:01:01", "DRB1*04:01:01", "DRB4*01:03:02", "E*01:03:02", "F*01:01:01", "TAP2*02:05")
dn = c("A*33:03:01", "B*42:01:01", "C*17:01:01", "DPA1*03:01:01", "DPB1*105:01:01", "E*01:01:01", "F*01:01:02", "Y*02:01")

## Run HLA_matrix
hla <- HLA_Matrix(reads = cts[["mRNA"]], cell_data_obj = seu, 
                  CB_rev_com = F,    # TRUE for 3prime 10x on pacbio
                  hla_recip = rp,
                  hla_donor = dn,
                  return_stats = F,
                  parallelize = F)
HLA.assay <- CreateAssayObject(counts = hla)
# map the alleles into seurat
suppressWarnings(seu@assays$HLA <- HLA.assay)
# normalize
DefaultAssay(seu) <- "HLA"
seu <- NormalizeData(seu, normalization.method = "LogNormalize", scale.factor = 100)

#------ Fig.2c, Suppl.Fig.S8e ------#
## HLA expression visuals

FeatP <- c()
for (i in 1:length(row.names(seu))) {
  g <- FeaturePlot_scCustom(seu, row.names(seu)[i], pt.size = 0.1)+
    theme(legend.position = "none", axis.line = element_blank(), 
          axis.text = element_blank(), axis.ticks = element_blank(), 
          axis.title = element_blank(), plot.title = element_text(size = 10))
  FeatP<- c(FeatP,list(g))
}
do.call("plot_grid", c(FeatP, align = "hv", ncol=floor(sqrt(length(FeatP))))) # for best visuals: 18 x 15 in

#------ Fig.2a ------#
## souporcell and viewmaster data have been previously calculated as described 
## in https://furlan-lab.github.io/viewmastR/
## and stored in the 'geno' and 'celltype' metadata columns of the 
## Seurat object (see also the "Seurat_Assemble" example workflow)
DimPlot_scCustom(seu, group.by = "celltype", colors_use = bmcolsl, pt.size = 0.4)
DimPlot_scCustom(seu, group.by = "geno", label = F, pt.size = 0.1,order = sort(unique(seu$geno), decreasing = T))+scale_color_manual(values=c("grey65", "red"))

#------ Fig.2b ------#
## load pre-aggregated data, previously collected using 'HLA_Matrix()' with arg 'return_stats = TRUE'
perstep_stats <- data.table::fread(file.path(DATA_DIR, paste0("AML4_per_step_stats-iter4.csv")), header = T, sep=",")
umi_dupl <- data.table::fread(file.path(DATA_DIR, paste0("AML4_umi_dupl-iter4.csv")), header = T, sep=",")

## rename some of the cols to look nice in the plot
perstep_stats <- mutate(perstep_stats, step = case_when(
  step == "0_raw_reads" ~ "0_Starting counts",
  step == "1_qc_mm2" ~ "1_1st Corr. (step 1)",
  step == "3_dedup" ~ "3_Dedup (step 3)",
  step == "7_ld_correct" ~ "7_Final Corr. (step 7)",
  TRUE ~ step # to keep the rest unchanged
))
pal5 <- pals::cols25()[c(22,23,17,16)]

## visualize UMI dupl
ggplot(umi_dupl, aes(x= rank, y=n_umi, color = sample))+
  #geom_smooth(size=2, method = "gam")+
  geom_line(linewidth = 0.75)+
  scale_y_log10(name = "PCR copies per UMI")+
  scale_x_continuous(name = "Rank (nth UMI)", n.breaks = 8) +
  annotation_logticks(sides = "l", outside = F, short = unit(0.75,"mm"), mid = unit(0.75,"mm"), long = unit(1.5,"mm"), size = 0.25)+
  theme_cowplot()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+scale_color_manual(values=pal5) # 3x7in

#------ Suppl.Fig.S8 ------#
## read numbers Sup Fig. S8b
ggplot(perstep_stats[perstep_stats$step %in% c("0_Starting counts", "1_1st Corr. (step 1)", "3_Dedup (step 3)", "7_Final Corr. (step 7)"),], aes(x= step, y= reads))+
  geom_bar(stat="identity", position=position_dodge(), alpha= 1)+
  scale_y_continuous(name = "number of sequenced reads", 
                     #trans= "log2",
                     n.breaks = 8)+
  scale_x_discrete(label=function(x) sub('..', '', x),
                   name = "HLA_matrix() steps")+
  facet_grid(~ sample)+ 
  theme_classic(14)+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) #4x6in

## CBs matching Seurat Sup Fig. S8c
ggplot(perstep_stats[perstep_stats$step %in% c("0_Starting counts", "1_1st Corr. (step 1)", "3_Dedup (step 3)", "7_Final Corr. (step 7)"),], aes(x= step, y= cbs_found, fill = cb_seu_match_rate))+
  geom_bar(stat="identity", position=position_dodge(width = 0.10), alpha= 1)+
  scale_y_continuous(name = "number of CBs matching in Seurat", n.breaks = 8)+
  scale_x_discrete(label=function(x) sub('..', '', x),
                   name = "HLA_matrix() steps")+
  scale_fill_gradientn(#limits = c(0,1),       #set gradient limits or comment out to let it autoset
                       colours = rev(viridis::viridis(n = 10, option = "C")), 
                       na.value = "grey35")+
  labs(fill="CBs to Seu\nmatch\nrate")+
  facet_grid(~ sample)+ 
  theme_classic(14)+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))#+scale_color_manual(values=bmcolsl) #4x7.2in

## Visualize HLA counts vs. corresponding HLA gene in the RNA assay Sup Fig S8d
## testing
seu@assays$HLA$data[1:3,1:3]
seu@assays$HLA$counts[1:3,1:3]
row.names(seu@assays$HLA)

## visualizing
DefaultAssay(seu) <- "HLA"
hla_gene <- "A"
select_hla <- row.names(seu@assays$HLA)[grep(paste0("^", hla_gene), row.names(seu@assays$HLA <- HLA.assay))]
select_rna <- paste0("HLA-", hla_gene)
soup <- 1 # souporcell 1 or 2
{
  seu_sub <- seu[ , rownames(seu@meta.data)[seu@meta.data$geno == sort(unique(seu@meta.data$geno))[soup]]]
  long_df <- cbind(
    seu_sub@assays$HLA$counts[select_hla, , drop = F] %>% as.data.frame() %>% t(),
    seu_sub@assays$RNA$counts[select_rna, , drop = F] %>% as.data.frame() %>% t()
  ) %>% as.data.frame() %>% reshape2::melt(., id.vars = select_rna, measure.vars = select_hla, variable.name = "HLA",)
  hla_rp <- gsub("[_*|?.+$^]", "-", rp)
  hla_dn <- gsub("[_*|?.+$^]", "-", dn)
  pal6 <- c("#FF7F00", "#DD4531","#89D5EC", "#74717E", "#B2DF8A", "#5BB57B")
  names(pal6) <- rep("dummy", length(pal6))
  #name the palette by the alleles depending on whether they are recip or donor or none:
  rp_index <- 1
  dn_index <- 5
  none_index <- 3
  for (hla in select_hla) {
    if (hla %in% hla_rp) {
      if (rp_index <= 2) {
        names(pal6)[rp_index] <- hla
        rp_index <- rp_index + 1
      }
    } else if (hla %in% hla_dn) {
      if (dn_index <= 6) {
        names(pal6)[dn_index] <- hla
        dn_index <- dn_index + 1
      }
    } else {
      if (none_index <= 4) {
        names(pal6)[none_index] <- hla
        none_index <- none_index + 1
      }
    }
  }
  ggplot(long_df, aes(long_df[,select_rna], value, colour = HLA)) + 
    geom_point(size = 1, alpha = 0.15)+
    ggpubr::stat_cor(method = "spearman")+
    geom_smooth(method = "lm", alpha = 0.15, aes(fill = HLA), linewidth = 0.5)+
    scale_y_continuous(name= paste(select_rna, "counts per CB (HLA pull-down)"),
                       trans = scales::pseudo_log_trans())+
    scale_x_continuous(name= paste(select_rna, "counts per CB (RNA 10x-assay)"),
                       trans = scales::pseudo_log_trans())+
    scale_color_manual(values=pal6)+scale_fill_manual(values=pal6)+
    guides(x =  guide_axis(angle = 90))+
    theme_cowplot() #3.5x4.5in
}

```

## Fig.3 
# HLA vs. ADT dotplot

```{r}
#------ Fig.3a ------#
## DimPlot of the viewmastR output
DimPlot_scCustom(seu, group.by = "celltype", colors_use = bmcolsl, pt.size = 0.4)

#------ Fig.3b ------#
hla_rp <- gsub("[_*|?.+$^]", "-", rp)
hla_dn <- gsub("[_*|?.+$^]", "-", dn)

## let's create a long dataframe for ADT vs. Normalized Gene Exp values per celltype. 
{
  longer_df <- list()
  named_pal <- c()
  hla_gene <- c("A", "DRA", "E")
  for (a in seq_along(hla_gene)) {
    select_hla <- row.names(seu@assays$HLA)[grep(paste0("^", hla_gene[a]), row.names(seu@assays$HLA))]
    select_adt <- paste0("HLA-", hla_gene[a], ".1")
    #ct <- levels(sort(unique(seu@meta.data$celltype)))
    for (soup in seq_along(sort(unique(seu@meta.data$geno)))) {
      seu_sub <- seu[ , rownames(seu@meta.data)[seu@meta.data$geno == sort(unique(seu@meta.data$geno))[soup]]]
      # seu_sub <- seu_sub[ , rownames(seu_sub@meta.data)[seu_sub@meta.data$celltype %in% ct[c(CT)] ]]
      long_df <- cbind(
        seu_sub@assays$HLA$counts[select_hla, , drop = F] %>% as.data.frame() %>% t(),
        seu_sub@assays$ADT$data[select_adt, , drop = F] %>% as.data.frame() %>% t(),
        seu_sub@meta.data[ ,"celltype", drop = F] %>% as.data.frame()
      ) %>% as.data.frame() %>% reshape2::melt(., id.vars = c(select_adt, "celltype"), measure.vars = select_hla, variable.name = "HLA",)
      colnames(long_df)[colnames(long_df) == select_adt] <- "ADT_value"
      long_df[c("gene", "leftover")] <- str_split_fixed(long_df$HLA, "-", 2)
      long_df$leftover <- NULL
      long_df$geno <- sort(unique(seu@meta.data$geno))[soup]
      longer_df <- c(longer_df, list(long_df))
      hla_rp <- gsub("[_*|?.+$^]", "-", rp)
      hla_dn <- gsub("[_*|?.+$^]", "-", dn)
      pal6 <- c("#FF7F00", "#DD4531","#89D5EC", "#74717E", "#B2DF8A", "#5BB57B")
      names(pal6) <- rep("dummy", length(pal6))
      #name the palette by the alleles depending on whether they are recip or donor or none:
      rp_index <- 1
      dn_index <- 5
      none_index <- 3
      for (hla in select_hla) {
        if (hla %in% hla_rp) {
          if (rp_index <= 2) {
            names(pal6)[rp_index] <- hla
            rp_index <- rp_index + 1
          }
        } else if (hla %in% hla_dn) {
          if (dn_index <= 6) {
            names(pal6)[dn_index] <- hla
            dn_index <- dn_index + 1
          }
        } else {
          if (none_index <= 4) {
            names(pal6)[none_index] <- hla
            none_index <- none_index + 1
          }
        }
      }
      named_pal <- c(named_pal, pal6)
    }
  }
  longer_df <- do.call("rbind", longer_df)
}  
  
{ ## we want to calculate spearman r for HLA assay vs. ADT 
  # only considering the mismatched or the shared alleles among the celltypes.
  # first let's identify the mismatched and shared alleles, 
  # and ignore the "false positives" i.e. the donor allele in recipient cells and vice versa
  l_df <- longer_df
  l_df$allele_belong <- ifelse(l_df$HLA %in% hla_rp, "Recipient", ifelse(l_df$HLA %in% hla_dn, "Donor", "Donor_Recipient"))
  l_df$allele_label <- ifelse(!mapply(function(x, y) grepl(x, y), l_df$geno, l_df$allele_belong), "FalsePos", ifelse(l_df$geno == l_df$allele_belong, "Mismatched", "Shared")) 
  l_df$concat <- paste0(l_df$celltype, ".", l_df$HLA, ".", l_df$geno, ".", l_df$allele_label) # if you want to use paste() instead, wrap it in a mapply() function, but it's slow.
  ## let's calculate the speearman r among the groups
  l_df <- split(data.table::setDT(l_df), by = "concat")
  l_df <- pbmcapply::pbmclapply(l_df, function(x){
    if (nrow(x) <= 1) { # needs to be enough observations or cor.test() will error
      x$Pval_spearman <- NA
      x$r_spearman <- NA
    } else {
      y <- stats::cor.test(x$ADT_value, x$value, method = "spearman", exact = F)
      x$Pval_spearman <- y[["p.value"]]
      x$r_spearman <- y[["estimate"]][["rho"]]
    }
    return(x)
  }, mc.cores = parallel::detectCores())
  ## no need for whole dataframes, just the first line will suffice
  deduped_df <- pbmcapply::pbmclapply(l_df, function(x){
    x <- data.table::setDF(x)
    x <- x[1,]
    return(x)
  }, mc.cores = parallel::detectCores())
  deduped_df <- data.table::rbindlist(deduped_df) 
  ## clean up the "false positives", log transform pvals 
  deduped_df <- deduped_df[!(deduped_df$allele_label %in% "FalsePos"), ]
  deduped_df$allele_and_label <- paste0(deduped_df$gene, " (", deduped_df$allele_label, ")")
  bonferroni <- F # do you want to apply a bonf correction?
  if (bonferroni) {
    deduped_df$Pval_bonferr <- ifelse(deduped_df$Pval_spearman*nrow(deduped_df) > 1, 1, deduped_df$Pval_spearman*nrow(deduped_df))
  } else {
    deduped_df$Pval_bonferr <- deduped_df$Pval_spearman
  }
  deduped_df$log_Pval <- -log10(deduped_df$Pval_bonferr)
  deduped_df$log_Pval_scaled <- ifelse(deduped_df$log_Pval > 16, 16, deduped_df$log_Pval)
  ## make data square to calculate euclidean distance and use ggtree
  deduped_df$concat2 <- paste0(deduped_df$gene, ".", deduped_df$allele_label, ".", deduped_df$geno)
  deduped_df <- split(data.table::setDT(deduped_df), by = "concat2")
  len <- lapply(deduped_df, function(x){
    l <- x$HLA %>% unique() %>% length()
    return(l)
  }) %>% unlist() %>% unname()
  deduped_df <- data.table::rbindlist(deduped_df) 
  if (any(len > 1)) {
    deduped_df$concat2 <- paste0(deduped_df$HLA, ".", deduped_df$allele_label, ".", deduped_df$geno)
    deduped_df$allele_and_label <- paste0(deduped_df$HLA, " (", deduped_df$allele_label, ")")
  }
  square_df <- deduped_df[ , c("celltype", "concat2", "r_spearman")] #keep only relevant cols
  square_df <- tidyr::pivot_wider(square_df, names_from = "concat2", values_from = "r_spearman") %>% as.data.frame()
  row.names(square_df) <- square_df$celltype
  square_df$celltype <- NULL
  square_df[is.na(square_df)] <- 0 # sometimes NAs need to be dealt with
  clust <- stats::hclust(dist(as.matrix(square_df), method = "euclidean")) # hclust with distance matrix
  # create dendrogram
  ggtree_plot <- ggtree::ggtree(as.dendrogram(clust))
  ## reorder the celltypes based on the hclust results using the factor trick
  deduped_df <- mutate(deduped_df, celltype = factor(celltype, levels = clust$labels[clust$order]))
  ## create the dotplot
  # col_fun <- circlize::colorRamp2(c(-1, -0.25, 0, 0.25, 1), c("#bc3754", "#f98e09", "black", "#fde725", "#5ec962"))
  col_fun <- circlize::colorRamp2(c(-10, 0, 10), c("red", "grey40", "green")) 
  dp <- ggplot(deduped_df, aes(x= allele_and_label, y= celltype, color= r_spearman, size= log_Pval_scaled))+
    geom_point()+
    # scale_x_discrete(label=function(x) sub('...', '', x))+
    # scale_y_discrete(label=function(x) sub('..', '', x))+
    scale_size(range = c(0, 5), name="-Log10(P-val)\nspearman")+
    scale_color_gradientn(
      name = "spearman rho",
      limits = c(-1,1), 
      colours = col_fun(c(-12:12)))+
    facet_wrap(~ geno, ncol = 2)+
    ggthemes::theme_few()+
    theme(text = element_text(size = 11), axis.title.x=element_blank(), axis.title.y=element_blank(),
          axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), axis.text.y = element_blank(),
          axis.ticks.y = element_blank(), plot.margin = margin(l = 0)) 
  
  labels <- ggplot(deduped_df, aes(x = 1, y = celltype, fill = celltype)) + 
    geom_tile() + 
    scale_fill_manual(values = bmcolsl) + # ATTENTION some samples are 'bmcolsl' and some are 'bmcolsl2'
    theme_nothing()
  
  plot_grid(ggtree_plot, NULL, labels, dp, nrow = 1, rel_widths = c(0.25, -0.05, 0.05, 2), align = 'h', axis = "bt") #the NULL plot with negative distance to squeeze the 2 plots
  # plot save at 4x4 in then scale down 60%
}
rm(longer_df) # it will be recreated in another section.

#------ Fig.3c ------#
CT <- 3
ct <- levels(as.factor(sort(unique(seu@meta.data$celltype))))
ct[CT]
{
  longer_df <- list()
  named_pal <- c()
  hla_gene <- c("A", "DRA", "E")
  for (a in seq_along(hla_gene)) {
    select_hla <- row.names(seu@assays$HLA)[grep(paste0("^", hla_gene[a]), row.names(seu@assays$HLA))]
    select_adt <- paste0("HLA-", hla_gene[a], ".1")
    #ct <- levels(sort(unique(seu@meta.data$celltype)))
    for (soup in seq_along(sort(unique(seu@meta.data$geno)))) {
      seu_sub <- seu[ , rownames(seu@meta.data)[seu@meta.data$geno == sort(unique(seu@meta.data$geno))[soup]]]
      seu_sub <- seu_sub[ , rownames(seu_sub@meta.data)[seu_sub@meta.data$celltype %in% ct[c(CT)] ]]
      long_df <- cbind(
        seu_sub@assays$HLA$counts[select_hla, , drop = F] %>% as.data.frame() %>% t(),
        seu_sub@assays$ADT$data[select_adt, , drop = F] %>% as.data.frame() %>% t(),
        seu_sub@meta.data[ ,"celltype", drop = F] %>% as.data.frame()
      ) %>% as.data.frame() %>% reshape2::melt(., id.vars = c(select_adt, "celltype"), measure.vars = select_hla, variable.name = "HLA",)
      colnames(long_df)[colnames(long_df) == select_adt] <- "ADT_value"
      long_df[c("gene", "leftover")] <- str_split_fixed(long_df$HLA, "-", 2)
      long_df$leftover <- NULL
      long_df$geno <- sort(unique(seu@meta.data$geno))[soup]
      longer_df <- c(longer_df, list(long_df))
      hla_rp <- gsub("[_*|?.+$^]", "-", rp)
      hla_dn <- gsub("[_*|?.+$^]", "-", dn)
      pal6 <- c("#FF7F00", "#DD4531","#89D5EC", "#74717E", "#B2DF8A", "#5BB57B")
      names(pal6) <- rep("dummy", length(pal6))
      #name the palette by the alleles depending on whether they are recip or donor or none:
      rp_index <- 1
      dn_index <- 5
      none_index <- 3
      for (hla in select_hla) {
        if (hla %in% hla_rp) {
          if (rp_index <= 2) {
            names(pal6)[rp_index] <- hla
            rp_index <- rp_index + 1
          }
        } else if (hla %in% hla_dn) {
          if (dn_index <= 6) {
            names(pal6)[dn_index] <- hla
            dn_index <- dn_index + 1
          }
        } else {
          if (none_index <= 4) {
            names(pal6)[none_index] <- hla
            none_index <- none_index + 1
          }
        }
      }
      named_pal <- c(named_pal, pal6)
    }
  }
  longer_df <- do.call("rbind", longer_df)
  
  ggplot(longer_df, aes(ADT_value, value, colour = HLA)) + 
    geom_point(size = 1, alpha = 0.5)+
    ggpubr::stat_cor(method = "spearman")+
    geom_smooth(method = "lm", alpha = 0.15, aes(fill = HLA), linewidth = 0.5)+
    scale_y_continuous(name= "Counts per Cell of HLA Transcripts (HLA pull-down assay)",
                       trans = scales::pseudo_log_trans())+
    scale_x_continuous(name= "Counts per Cell of HLA Cell Surface Molecules (ADT assay; CLR normalized)")+ #,
    scale_color_manual(values=named_pal)+scale_fill_manual(values=named_pal)+
    facet_wrap(gene ~ geno, scales = "free", ncol = 2)+
    theme_cowplot()#11x8.5in (US Letter) then scale down to 50%
}
```

## Fig.4, Suppl.Fig.S12
## small changes in HLA haplotype

```{r}

#------ Fig.4a -----#
## HLA gene positions according to hg38

#------ Fig.4b, Suppl.Fig.S12a ------#
## genotype is deduced by looking at the HLA expression in each genotype class 
## and confirming by available clinical data

#------ Suppl.Fig.S12b ------#
## DimPlot of the viewmastR output
DimPlot_scCustom(seu, group.by = "celltype", colors_use = bmcolsl, pt.size = 0.4)

#------ Fig.4c, Suppl.Fig.S12c ------#
pal_malig <- c(Don_Healthy = "grey85", Rcp_Healthy = "red", Rcp_Malignant ="violetred4")
seu@active.ident <- as.factor(seu$malignant)
seu@active.ident
DimPlot_scCustom(seu, group.by = "malignant", reduction = "umap", pt.size=0.4, shuffle = T, seed = 100) +scale_color_manual(values= pal_malig, drop=F) # drop=F to show a level in legend even if it is unused in the plot (4in x 6in)

DefaultAssay(seu) <- "HLA"
Idents(seu)<-seu$malignant
old.lvl<-levels(Idents(seu)) %>% sort()
Idents(seu) <- factor(Idents(seu), levels = old.lvl)
rm(old.lvl)
# run this chunk to generate the figure
{
  av.expr1 <- SummarizedExperiment::assay(muscat::aggregateData(as.SingleCellExperiment(seu), by = c("ident"), fun = "mean")) %>% as.data.frame() %>% suppressWarnings() 
  av.expr2 <- SummarizedExperiment::assay(muscat::aggregateData(as.SingleCellExperiment(seu), by = c("ident"), fun = "prop.detected")) %>% as.data.frame() %>% suppressWarnings()
  if (length(colnames(av.expr1)) < length(levels(Idents(seu)))) { #check if levels of seu idents are equal to the cols in the av.expr dataframes
    av.expr1[, setdiff(levels(Idents(seu)), colnames(av.expr1))] <- 0 #force the missing levels as a col with data at no value (zeros)
    av.expr1 <- av.expr1[ , levels(Idents(seu))]
  }
  if (length(colnames(av.expr2)) < length(levels(Idents(seu)))) { 
    av.expr2[, setdiff(levels(Idents(seu)), colnames(av.expr2))] <- 0
    av.expr2 <- av.expr2[ , levels(Idents(seu))]
  }
  hla_rp <- gsub("[_*|?.+$^]", "-", rp)
  hla_dn <- gsub("[_*|?.+$^]", "-", dn)
  av.expr1$AlleleOrigin <- ifelse(rownames(av.expr1) %in% hla_rp, "3_recipient-spec", ifelse(rownames(av.expr1) %in% hla_dn, "1_donor-spec", "2_shared/homoz"))
  av.expr2$AlleleOrigin <- ifelse(rownames(av.expr2) %in% hla_rp, "3_recipient-spec", ifelse(rownames(av.expr2) %in% hla_dn, "1_donor-spec", "2_shared/homoz"))
  av.expr1[c("hla", "x")] <- str_split_fixed(rownames(av.expr1), "-", 2)
  av.expr2[c("hla", "x")] <- str_split_fixed(rownames(av.expr2), "-", 2)
  av.expr1$x <- NULL
  av.expr2$x <- NULL
  av.expr1$gene_pos <- av.expr1$hla
  av.expr2$gene_pos <- av.expr2$hla
  gen.ord <- c("HFE","F","G","H","A","Y","E","C","B","MICA","MICB","DRA","DRB9","DRB3","DRB4","DRB5","DRB1","DQA1","DQB1","DQA2","DQB2","DOB","TAP2","TAP1","Z","DMB","DMA","DOA","DPA1","DPB1","DPA2","DPB2")
  names(gen.ord) <- paste0(str_pad(seq_along(gen.ord), 2, pad = "0"), "_", gen.ord)
  for (i in seq_along(gen.ord)) {
    av.expr1$gene_pos <- ifelse(av.expr1$gene_pos == gen.ord[i], names(gen.ord)[i], av.expr1$gene_pos) #manually enter gene order as they appear on chromosome 6 
  }
  for (i in seq_along(gen.ord)) {
    av.expr2$gene_pos <- ifelse(av.expr2$gene_pos == gen.ord[i], names(gen.ord)[i], av.expr2$gene_pos) #manually enter gene order as they appear on chromosome 6 
  }
  av.expr1 <- av.expr1[order(av.expr1$gene_pos),]
  av.expr2 <- av.expr2[order(av.expr2$gene_pos),]
  av.expr3 <- av.expr1
  av.expr4 <- av.expr2
  av.expr3 <- split(data.table::setDT(av.expr3), by = "hla") 
  av.expr4 <- split(data.table::setDT(av.expr4), by = "hla")
  fun.ratio <- function(df) {
    df <- data.table::setDF(df)
    if (any(grepl("shared", df$AlleleOrigin))) {
      lv <- list()
      for (i in 1:length(levels(Idents(seu)))) {
        # chosing the value of the "shared" allele for a given HLA gene
        lv[[i]] <- df[,i][grepl("shared", df$AlleleOrigin)]
        # get the ratios over the shared allele value
        df[,i] <- df[,i]/lv[[i]][[1]]
      }
    } else {
      for (i in 1:length(levels(Idents(seu)))) {
        df[,i] <- NA
      }
    }
    df <- data.table::setDT(df)
    return(df)
  }
  av.expr3 <- pbmcapply::pbmclapply(av.expr3, fun.ratio, mc.cores = 1) 
  av.expr4 <- pbmcapply::pbmclapply(av.expr4, fun.ratio, mc.cores = 1) 
  av.expr3 <- data.table::rbindlist(av.expr3)
  av.expr4 <- data.table::rbindlist(av.expr4)
  av.expr.mlt1 <- reshape2::melt(av.expr1, id.vars = "AlleleOrigin", measure.vars = colnames(av.expr1[,1:length(levels(Idents(seu)))]), variable.name = "cell_grp",)
  av.expr.mlt2 <- reshape2::melt(av.expr2, id.vars = "AlleleOrigin", measure.vars = colnames(av.expr2[,1:length(levels(Idents(seu)))]), variable.name = "cell_grp",)
  av.expr.mlt3 <- reshape2::melt(av.expr3, id.vars = "AlleleOrigin", measure.vars = colnames(av.expr3[,1:length(levels(Idents(seu)))]), variable.name = "cell_grp",)
  av.expr.mlt4 <- reshape2::melt(av.expr4, id.vars = "AlleleOrigin", measure.vars = colnames(av.expr4[,1:length(levels(Idents(seu)))]), variable.name = "cell_grp",)
  colnames(av.expr.mlt1)[which(names(av.expr.mlt1) == "value")] <- "MeanNormExpr"
  colnames(av.expr.mlt2)[which(names(av.expr.mlt2) == "value")] <- "PropExpr"
  colnames(av.expr.mlt3)[which(names(av.expr.mlt3) == "value")] <- "MeanNormExprRatioOverShared"
  colnames(av.expr.mlt4)[which(names(av.expr.mlt4) == "value")] <- "PropExprRatioOverShared"
  av.expr.mlt <- cbind(av.expr.mlt1, 
                       av.expr.mlt2[which(names(av.expr.mlt2) == "PropExpr")],
                       av.expr.mlt3[which(names(av.expr.mlt3) == "MeanNormExprRatioOverShared")],
                       av.expr.mlt4[which(names(av.expr.mlt4) == "PropExprRatioOverShared")])
  av.expr.mlt$gene_pos <- av.expr1$gene_pos
  rm(av.expr.mlt1,av.expr.mlt2,av.expr.mlt3,av.expr.mlt4)
  av.expr.mlt$under_press_MeanNormExprRatioOverShared <- ifelse(
    (grepl("d[[:alnum:]]*n", av.expr.mlt$AlleleOrigin, ignore.case = T) & grepl("d[[:alnum:]]*n", av.expr.mlt$cell_grp, ignore.case = T)) | 
      (grepl("r[[:alnum:]]*p", av.expr.mlt$AlleleOrigin, ignore.case = T) & grepl("r[[:alnum:]]*p", av.expr.mlt$cell_grp, ignore.case = T)), av.expr.mlt$MeanNormExprRatioOverShared, NA
  )# identify under pressure alleles (the non-shared allele)
  av.expr.mlt$under_press_PropExprRatioOverShared <- ifelse(
    (grepl("d[[:alnum:]]*n", av.expr.mlt$AlleleOrigin, ignore.case = T) & grepl("d[[:alnum:]]*n", av.expr.mlt$cell_grp, ignore.case = T)) | 
      (grepl("r[[:alnum:]]*p", av.expr.mlt$AlleleOrigin, ignore.case = T) & grepl("r[[:alnum:]]*p", av.expr.mlt$cell_grp, ignore.case = T)), av.expr.mlt$PropExprRatioOverShared, NA
  )
  av.expr.mlt$under_press_MeanNormExprRatioOverShared[is.infinite(av.expr.mlt$under_press_MeanNormExprRatioOverShared)] <- NA
  av.expr.mlt$under_press_PropExprRatioOverShared[is.infinite(av.expr.mlt$under_press_PropExprRatioOverShared)] <- NA
  av.expr.mlt$MeanNormExprRatioOverShared_updown <- ifelse(av.expr.mlt$MeanNormExprRatioOverShared > 1, "increase", ifelse(av.expr.mlt$MeanNormExprRatioOverShared < 1, "decrease", NA))
  av.expr.mlt$PropExprRatioOverShared_updown <- ifelse(av.expr.mlt$PropExprRatioOverShared > 1, "increase", ifelse(av.expr.mlt$PropExprRatioOverShared < 1, "decrease", NA))
  
  col_fun <- circlize::colorRamp2(c(0, 1, 3, 6, 12), c("black", "#f0f921", "#ed7953", "#9c179e", "#0d0887")) #based on viridis plasma
  ggplot(av.expr.mlt, aes(x= gene_pos, y= AlleleOrigin, color= MeanNormExpr, size= PropExpr))+
    geom_point()+
    scale_x_discrete(label=function(x) sub('...', '', x))+
    scale_y_discrete(label=function(x) sub('..', '', x))+
    scale_size(range = c(.1, 5), name="Proportion\nExpressed")+
    scale_color_gradientn(
      name = "Mean\nNormalized\nExpression",
      limits = c(0,max(av.expr.mlt$MeanNormExpr)), 
      colours = col_fun(c(0:max(av.expr.mlt$MeanNormExpr))))+
    facet_wrap(~ cell_grp, nrow = 3)+
    ggthemes::theme_few()+
    theme(text = element_text(size = 11),axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # 3.25x5 in  then scale 60%
}


#------ Fig.4d ------#
pal4 <- c("grey85", "red", "violetred4")
Stacked_VlnPlot(seu, features = c("DRB1-04:01:01", "DRB1-03:02:01"), #DRB1
                x_lab_rotate = TRUE, split.by = "malignant", colors_use = pal4, plot_legend =T)

#------ Fig.4e, Suppl.Fig.S12d ------#

{ ## Adding the p-values from Chi.square testing 
  # make sure the idents are still from the metadata col that you want
  Idents(seu)
  seu_malig <- Idents(seu) %>% unique() %>% sort()
  # subset the seu 
  seus <- c()
  for (i in 1:length(seu_malig)) {
    s <- subset(seu, idents = seu_malig[i])
    seus <- c(seus, s)
  }
  rm(s)
  names(seus) <- seu_malig
  # get the counts from the HLA assay
  seus <- lapply(seus, function(seu){
    cts <- seu@assays$HLA$counts %>% as.data.frame()
  })
  # a function to summarize counts as zeros and non-zeros
  summarize_cts <- function(cts) {
    cts <- t(apply(cts, 1, function(row) {
      zeros <- sum(row == 0)
      non_zeros <- sum(row > 0)
      return(c(zeros, non_zeros))
    }))
    colnames(cts) <- c("Neg_counts", "Pos_counts")
    return(cts)
  }
  # apply the funtion
  seus <- lapply(seus, summarize_cts)
  seus <- lapply(seus, as.data.frame)
  # define the HLA alleles specific of the donor and the recip
  hla_rp <- gsub("[_*|?.+$^]", "-", rp)
  hla_dn <- gsub("[_*|?.+$^]", "-", dn)
  seus <- lapply(seus, function(cts) {
    cts$AlleleOrigin <- ifelse(rownames(cts) %in% hla_rp, "3_recipient-spec", ifelse(rownames(cts) %in% hla_dn, "1_donor-spec", "2_shared/homoz"))
    cts[c("hla", "x")] <- str_split_fixed(rownames(cts), "-", 2)
    cts$x <- NULL
    cts$gene_pos <- cts$hla
    gen.ord <- c("HFE","F","G","H","A","Y","E","C","B","MICA","MICB","DRA","DRB9","DRB3","DRB4","DRB5","DRB1","DQA1","DQB1","DQA2","DQB2","DOB","TAP2","TAP1","Z","DMB","DMA","DOA","DPA1","DPB1","DPA2","DPB2")
    names(gen.ord) <- paste0(str_pad(seq_along(gen.ord), 2, pad = "0"), "_", gen.ord)
    for (i in seq_along(gen.ord)) {
      cts$gene_pos <- ifelse(cts$gene_pos == gen.ord[i], names(gen.ord)[i], cts$gene_pos)
    }
    cts <- cts[order(cts$gene_pos),]
    return(cts)
  })
  # get the names of the dataframes in seus
  for (i in seq_along(seus)) {
    df_name <- names(seus)[i]
    seus[[i]]$seu_subset <- df_name
  }
  # identify underpressure allele
  seus <- lapply(seus, function(cts) {
    cts$underprss <- ifelse(
      (grepl("d[[:alnum:]]*n", cts$AlleleOrigin, ignore.case = T) & grepl("d[[:alnum:]]*n", cts$seu_subset, ignore.case = T)) | 
        (grepl("r[[:alnum:]]*p", cts$AlleleOrigin, ignore.case = T) & grepl("r[[:alnum:]]*p", cts$seu_subset, ignore.case = T)), "underpressure", ifelse(grepl("shared", cts$AlleleOrigin, ignore.case = T), "shared/hmz", NA)
    )
    cts$mlog.pval.chisq <- NA #introduce the p-val for the test later
    cts <- transform(cts, mlog.pval.chisq = as.numeric(mlog.pval.chisq))
    return(cts)
  })
  # define a function to run chisq tests
  chisq_processing <- function(df) {
    if (all(c("underpressure", "shared/hmz") %in% df$underprss)) {
      tmp <- df[which(df$underprss %in% c("underpressure", "shared/hmz")), ]
      tmp <- tmp[, 1:2]
      test <- chisq.test(tmp, correct = F) %>% suppressWarnings() 
      p_value <- test$p.value 
      df$mlog.pval.chisq <- -log10(p_value)
    }
    return(df)
  }
  # split the dataframes
  seus <- lapply(seus, function(cts) {
    cts <- split(data.table::setDT(cts), by = "hla") 
    cts <- pbmcapply::pbmclapply(cts, chisq_processing, mc.cores = 1)
    cts <- data.table::rbindlist(cts)
    return(cts)
  })
  # now rbind everything
  allele_cts <- data.table::rbindlist(seus)
  # bring the p-values to the "melted" dataframe, ready for plotting
  av.expr.mlt$tmp <- paste0(av.expr.mlt$gene_pos, "_", av.expr.mlt$cell_grp)
  allele_cts$tmp <- paste0(allele_cts$gene_pos, "_", allele_cts$seu_subset)
  av.expr.mlt$mlog.pval.chisq <- NA
  av.expr.mlt$mlog.pval.chisq <- allele_cts$mlog.pval.chisq[match(av.expr.mlt$tmp, allele_cts$tmp)]
  av.expr.mlt$mlog.pval.chisq <- ifelse(is.na(av.expr.mlt$under_press_PropExprRatioOverShared), NA, av.expr.mlt$mlog.pval.chisq)
  av.expr.mlt$tmp <- NULL
  allele_cts$tmp <- NULL
  col_fun <- circlize::colorRamp2(c(0, 5, 50), 
                                  c("red", "#00FF00", "darkturquoise")) 
  # fix infinities in the minus log p-val (which originate from p-val themselves = 0):
  av.expr.mlt$mlog.pval.chisq[is.infinite(av.expr.mlt$mlog.pval.chisq)] <- max(av.expr.mlt$mlog.pval.chisq[is.finite(av.expr.mlt$mlog.pval.chisq)])
  
  ggplot(av.expr.mlt, aes(x= gene_pos, y=scales::squish(under_press_PropExprRatioOverShared, c(0.1,10)), fill=mlog.pval.chisq))+
    geom_bar(stat="identity", alpha= 1, linetype = 0) +
    scale_x_discrete(label=function(x) sub('...', '', x))+
    scale_y_log10(name = "", #proportion recipient (Chimerocyte)
                  breaks = c(0.01, 0.1, 1, 10),
                  labels = c(0.01, 0.1, 1, 10),
                  limits = c(0.1, 10))+
    annotation_logticks(sides = "l", outside = F, short = unit(0.75,"mm"), mid = unit(0.75,"mm"), long = unit(1.5,"mm"), size = 0.25)+
    # coord_cartesian(clip = "off")+  # Ticks outside plot
    geom_hline(yintercept=1, linetype="dashed", color = "grey30", linewidth = 0.25, alpha = 0.75)+
    scale_fill_gradientn(
      name = "-Log(Pval)\nChi.square",
      limits = c(0,max(av.expr.mlt$mlog.pval.chisq[is.finite(av.expr.mlt$mlog.pval.chisq)])), 
      colours = col_fun(c(0:max(av.expr.mlt$mlog.pval.chisq[is.finite(av.expr.mlt$mlog.pval.chisq)]))))+
    facet_wrap(~ cell_grp, nrow = 3)+
    ggthemes::theme_few()+
    theme(text = element_text(size = 11),axis.title.x=element_blank(),axis.title.y=element_blank(),axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # 3.25x4.90 in  then scale 50%
}

#------ Fig.4f ------#
## try it by re-running the chunk of Fig.4c with:
Idents(seu)<-seu$geno
{
  logpval.thr <- 2
  effect.size.thr <- 2
  av.expr.mlt$thresh.eff.pval <- ifelse(av.expr.mlt$mlog.pval.chisq > logpval.thr & 
                                          (av.expr.mlt$under_press_PropExprRatioOverShared > effect.size.thr |
                                             av.expr.mlt$under_press_PropExprRatioOverShared < 1/effect.size.thr), "Differential", "Balanced")
  tab <- table(av.expr.mlt$cell_grp, av.expr.mlt$thresh.eff.pval) %>% data.frame()
  fill.leg <- paste("mismatched vs. shared\nexpression status\ngiven fold-change >", effect.size.thr, "\n(increase or decrease)\nand p-val <", 10^-logpval.thr)
  ggplot(tab, aes(x=Var1, y=Freq, fill=Var2))+
    geom_bar(stat="identity", position = "fill")+
    scale_fill_manual(values = c("#0073C2FF", "#EFC000FF"))+
    labs(x = "Var1", y = "Proportion", fill = fill.leg) +
    theme_classic() + 
    theme(axis.line=element_blank(), axis.title.x=element_blank(),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) # 3 x 3 in
}
```

## Fig. 5
# Using RSAMTOOLS, BIOCONDUCTOR, and MERGBAMR to VISUALIZE HLA ALIGNMENTS
# Match DNA on chromosome 6 of hg38

```{r}

#------ Fig. 5a & 5b ------#
# if not already
#remotes::install_github("https://github.com/furlan-lab/BSgenome.Hsapiens.scrHLAtyping.imgtHLA")

suppressPackageStartupMessages({
  library(mergebamsR)
  library(Rsamtools)
  library(GenomicAlignments)
  library(GenomeInfoDb)
  library(BSgenome) 
  library(dplyr)
  library(ggbio)
  library(TxDb.Hsapiens.UCSC.hg38.knownGene)
  library(BSgenome.Hsapiens.scrHLAtyping.imgtHLA)
})
options(ucscChromosomeNames = FALSE)

# creating an temporary out path for our merged bams
outpath<-"/hpc/temp/furlan_s/skanaan"

samples<-unique(sapply(colnames(seu), function(i){
  i<-strsplit(i, "_")
  paste(i[[1]][1:length(i[[1]])-1], collapse = "_")  
}))

## what is the base sample name?
longest_common_substring <- function(strs) {
  # pick the shortest string as a base
  base <- strs[[which.min(nchar(strs))]]
  n    <- nchar(base)
  # check all substrings from longest to shortest
  for(len in seq(n, 1)) {
    for(start in seq_len(n - len + 1)) {
      candidate <- substr(base, start, start + len - 1)
      if (all(vapply(strs, \(s) grepl(candidate, s, fixed = TRUE), logical(1))))
        return(candidate)
    }
  }
  return("")  # no common substring
}

## Match the patient names with their respective count data directories
dirs_path <- "/fh/fast/furlan_s/user/skanaan/scrHLAtyping/WorkFlowTest_AML401/pacbio_isoseq_scrHLAtag_out"
dirs<-list.dirs(path=dirs_path, full.names = T, recursive = F)
dirs<- lapply(dirs, list.dirs, recursive = F) %>% unlist
dirs<- lapply(dirs, dir, pattern = "^guid", recursive = F, full.names = T) %>% unlist
names(dirs) <- c("AML401_BM", "AML401_34") # this is how the samples were organized in the directories

bams<- lapply(dirs, dir, pattern = "Aligned_mm2_sorted_mRNA\\.bam$", recursive = F, full.names = T) %>% unlist # `\\.` escaping the dot to mean litteral dot, `$` to anchor the end of the string so the index files `.bam.bai` no longer match
bams<- lapply(1:length(samples), function(x) bams[which.min(stringdist::stringdist(samples[x], names(bams), method = "lv"))]) %>% unlist
bams

# Make sure the bams are formatted correctly, the "CB" tag must be present
peekbam(bam = bams[1], field = "tag", TAG = "CB", n=10)
peekbam(bam = bams[2], field = "tag", TAG = "CB", n=10)

## Merge bams
seu_cb_sepr <- "_"
seu_cb_sufx <- "-1"
mergebams(bams = c(bams[1], bams[2]), out_path = outpath, prefixes = paste0(samples, seu_cb_sepr))
peekbam(bam = paste0(outpath, "/out_path.bam"), field = "tag", TAG = "CB", n=10)
Rsamtools::sortBam(paste0(outpath, "/out_path.bam"), destination = sub("\\.bam$", ".sorted", paste0(outpath, "/out_path.bam")))
Rsamtools::indexBam(paste0(outpath, "/out_path.sorted.bam"))

## Subset bams according to Seurat clsssifications
# seu@active.ident <- as.factor(seu$geno)
seu@active.ident
levels(seu)
mismatch_patterns <- lapply(1:length(levels(seu)), function(mal) {
  #mal <- 3
  ft <- colnames(seu[ , rownames(seu@meta.data)[seu@active.ident == levels(seu)[mal]]])
  suf <- seu_cb_sufx
  ft <- sub(paste0(suf, "$"), "", ft) #paste0(suf, "$") builds the regex "-1$" (i.e. '-1' at end of string)
  if (file.exists(paste0(outpath, "/merged_subset_by_feat.bam"))) {
    file.remove(paste0(outpath, "/merged_subset_by_feat.bam"))
  }
  subsetbam(
    inputbam = paste0(outpath, "/out_path.sorted.bam"),
    features = list(ft),
    outputbams = paste0(outpath, "/merged_subset_by_feat.bam"),
    field = "tag", dump_bam = NA, TAG = "CB",
    cores = 1, verbose = T, split_bam = F
  )
  Rsamtools::countBam(paste0(outpath, "/merged_subset_by_feat.bam"))$records
  Rsamtools::indexBam(paste0(outpath, "/merged_subset_by_feat.bam"))
  
  #Set up your working Bam file and reference fasta:
  bam_path <- paste0(outpath, "/merged_subset_by_feat.bam")
  reads <- readGAlignments(bam_path)
  mismatch_data <- pbmcapply::pbmclapply(1:length(levels(reads@seqnames@values)), function(x){
    ctg <- levels(reads@seqnames@values)[x]
    window <- GRanges(ctg, IRanges(1, seqlengths(BSgenome.Hsapiens.scrHLAtyping.imgtHLA)[ctg]))
    pp <- PileupParam(
      distinguish_nucleotides = TRUE,
      distinguish_strands = FALSE,
      min_base_quality = 0, 
      include_deletions = TRUE,
      include_insertions = TRUE,
      max_depth = 1e5
    )
    pu <- pileup(
      file = bam_path,
      scanBamParam = ScanBamParam(which=window),
      pileupParam = pp
    )
    ref_seq <- BSgenome.Hsapiens.scrHLAtyping.imgtHLA[[ctg]]#[ start(window):end(window) ] #if only part of a seq is needed
    ref_bases <- strsplit(as.character(ref_seq), split="")[[1]]
    mismatch_df <- pu %>%
      group_by(pos) %>%
      summarise(
        depth = sum(count, na.rm=TRUE),
        mismatches = sum(count[nucleotide != ref_bases[pos]], na.rm=TRUE)
      ) %>%
      mutate(rate = mismatches / depth)
    # classify indels and mismatches
    pu2 <- pu %>%
      mutate(type = case_when(
        nucleotide == "-" ~ "deletion",
        nucleotide == "+" ~ "insertion",
        nucleotide %in% c("A","C","G","T") &
          nucleotide != ref_bases[pos] ~ "substitution",
        nucleotide %in% c("A","C","G","T") &
          nucleotide == ref_bases[pos] ~ "_match",
        TRUE ~ NA_character_
      )) %>%
      filter(!is.na(type))
    # compute rates:
    rate_df <- pu2 %>%
      group_by(pos, type) %>%
      summarise(count = sum(count), .groups="drop") %>%
      group_by(pos) %>%
      mutate(depth = sum(count), rate = count / depth) %>%
      ungroup()
    rate_df$sample <- longest_common_substring(samples)
    rate_df$subsample <- levels(seu)[mal]
    rate_df$allele <- gsub("\\|", "*", ctg)
    sn <- seqnames(reads) %>% as.data.frame()
    if (ctg %in% sn$value) {
      p_cov <- autoplot(
        BamFile(bam_path),
        stat = "coverage",
        which = window,
        geom = "bar"
      ) + ggthemes::theme_few()
      p_cov <- p_cov@ggplot[["layers"]][[1]][["data"]]
      p_cov$seqnames <- gsub("\\|", "*", p_cov$seqnames)
    } else {
      p_cov <- NULL
    }
    return(list(pu = rate_df, cov = p_cov))
  }, mc.cores = parallel::detectCores())
  mm <- lapply(mismatch_data, `[[`, 1)
  mm <- do.call("rbind", mm)
  covl <- lapply(mismatch_data, `[[`, 2)
  covl <- covl[!sapply(covl, is.null)]
  covl <- do.call("rbind", covl)
  rownames(covl) <- NULL
  return(list(pileup = mm, coverage = covl))
})
coverage_patterns <- lapply(mismatch_patterns, `[[`, 2)
mismatch_patterns <- lapply(mismatch_patterns, `[[`, 1)
names(mismatch_patterns) <- sapply(mismatch_patterns, function(df) unique(df$subsample))
names(coverage_patterns) <- names(mismatch_patterns)

dn # list of donor specific alleles
rp # list of recip specific alleles 
ch <- list(dn=dn, rp=rp, rp=rp) # follow the naming convention in `mismatch_patterns`
sh <- gsub("-", "\\*", row.names(seu))
sh <- sh[! sh %in% c(rp, dn)] #shared alleles

d <- 1
al <- c(ch[[d]], sh)
# al <- c(ch[[d]], sh)[1]
p_var_sub <- ggplot(mismatch_patterns[[d]][which(mismatch_patterns[[d]]$allele %in% al ),], aes(x = pos, y = rate, fill = type)) +
  geom_col(colour = NA, alpha = 1, width = 1.1) +
  scale_fill_manual(values = c(substitution = "forestgreen", insertion = "blue", deletion = "red", `_match` = "gray95")) +
  scale_y_continuous(labels = scales::percent_format(1), expand = expansion(mult = c(.01, .01))) +
  # labs(title = paste("Variants in reads mapped to", gsub("\\|", "*", ctg)), x = "Position", y = "% reads with variant", fill = "Type" ) +
  facet_wrap( ~ allele, scales = "free_x") +
  scale_x_continuous(expand = expansion(mult = c(.01, .01)))+
  # scale_y_continuous(expand = expansion(mult = c(.01, .01)))+
  ggthemes::theme_few() +
  theme(panel.border = element_rect(colour = "black", size = .1, fill = NA))
p_var_sub

p_cov <- ggplot(coverage_patterns[[d]][which(coverage_patterns[[d]]$seqnames %in% al ),], aes(x = seqs, y = coverage)) +
  geom_col(fill = "#6A3D9A", colour = NA, alpha = 1, width = 1.1) +
  facet_wrap( ~ seqnames, scales = "free") +
  scale_x_continuous(expand = expansion(mult = c(.01, .01)))+
  scale_y_continuous(expand = expansion(mult = c(.03, .03)))+
  ggthemes::theme_few() +
  theme(panel.border = element_rect(colour = "black", size = .1, fill = NA), axis.text.x = element_blank(), axis.title.x = element_blank())
p_cov


#------ Fig. 5c ------#

## while exploring the scrHLAtag bam files from AML8, we identify this sequence as an unususally frequent insertion:
seq18 <- DNAString("AGGTGGAGAAGGGGTGAA") 

#is it possible it is part of the HLA loci? let's download the hg38 part that has HLA: chromosome 6
options(timeout = 600)
download.file(
  "https://hgdownload.soe.ucsc.edu/goldenPath/hg38/chromosomes/chr6.fa.gz",
  "chr6.fa.gz"
)
chr6 <- readDNAStringSet("chr6.fa.gz")
hits_list <- vmatchPattern(seq18, chr6, max.mismatch = 0)
hits_list
chr <- "6"   # "6" Ensembl style "chr6" USCS style
names(chr6) <- chr   

# extract the matches for the first (and only) element:
hits <- hits_list[[1]]
df <- as.data.frame(hits)
df$seqnames <- names(chr6)

# define your window
hit.start <- df$start
hit.end <- df$end
upstream <- hit.start - 10
downstream <- hit.end + 10
region <- GRanges(chr, IRanges(upstream, downstream))

gtf_url <- "ftp://ftp.ensembl.org/pub/release-112/gtf/homo_sapiens/Homo_sapiens.GRCh38.112.gtf.gz"
gtf_dest <- file.path("/fh/fast/furlan_s/user/skanaan/temp/Homo_sapiens.GRCh38.112.gtf.gz")
download.file(gtf_url, gtf_dest, mode = "wb") #download only once
#grabbing all transcripts overlapping a specific region
region <- GRanges(
  seqnames = "6",
  ranges = IRanges(start = 29942532, end = 29945870)
)
gtf <- import(gtf_dest, format="gtf", which=region)
txdb <- makeTxDbFromGFF(gtf_dest, format="gtf")

all_txs <- transcripts(
  txdb,
  columns = c("tx_id","gene_id"),   # pull whatever metadata you like
  use.names = TRUE
)
tx_hits <- subsetByOverlaps(all_txs, region)
tx_feats <- gtf[gtf$type == "transcript"]
tx_feats <- as.data.frame(tx_feats)

#expanding by exon
exon_ranges <- pbmcapply::pbmclapply(1:nrow(tx_feats), function(t) {
  ex_gr   <- exonsBy(txdb, by="tx", use.names=TRUE)[[ tx_feats$transcript_id[t] ]]
  ex_gr <- as.data.frame(ex_gr)
  ex_gr$mRNA.part <- "coding"
  utr5_gr <- fiveUTRsByTranscript(txdb, use.names=TRUE)[[ tx_feats$transcript_id[t] ]]
  if (is.null(utr5_gr)) {
    utr5_gr <- setNames(data.frame(matrix(nrow = 0, ncol = length(colnames(ex_gr)))), colnames(ex_gr))
  } else {
    utr5_gr <- as.data.frame(utr5_gr)
    utr5_gr$mRNA.part <- "5UTR"
  }
  utr3_gr <- threeUTRsByTranscript(txdb, use.names=TRUE)[[ tx_feats$transcript_id[t] ]]
  if (is.null(utr3_gr)) {
    utr3_gr <- setNames(data.frame(matrix(nrow = 0, ncol = length(colnames(ex_gr)))), colnames(ex_gr))
  } else {
    utr3_gr <- as.data.frame(utr3_gr)
    utr3_gr$mRNA.part <- "3UTR"
  }
  ex_gr <- do.call("rbind", list(ex_gr, utr5_gr, utr3_gr))
  ex_gr$transcript_id <- tx_feats$transcript_id[t]
  ex_gr$transcript_biotype <- tx_feats$transcript_biotype[t]
  ex_gr$tag <- tx_feats$tag[t]
  ex_gr$gene.start <- tx_feats$start[t]
  ex_gr$gene.end <- tx_feats$end[t]
  ex_gr$order_in_df <- t
  return(ex_gr)
}, mc.cores = parallel::detectCores())
exon_ranges <- do.call("rbind", exon_ranges)
exon_ranges$transcript_biotype <- with(exon_ranges, ifelse(!is.na(tag) & tag == "MANE_Select", paste0(transcript_biotype, ";MANE_tag"), transcript_biotype))

# set our zoom coordinates 
zoom.min <- exon_ranges$start[which.min(exon_ranges$start)]
zoom.max <- exon_ranges$end[which.max(exon_ranges$end)]

# draw your HLA-A gene
# tick positions to represent introns
exon_ranges2 <- exon_ranges[which(exon_ranges$mRNA.part == "coding"),]
exon_rangesutr <- exon_ranges[which(exon_ranges$mRNA.part %in% c("5UTR", "3UTR")),]
tick_df <- exon_ranges2 %>%
  group_by(transcript_id, order_in_df, strand) %>%
  filter(n() > 1) %>%
  arrange(exon_rank, .by_group=TRUE) %>%
  mutate(next_start = lead(start),
         curr_end   = end) %>%
  filter(!is.na(next_start)) %>%
  ungroup() %>%
  transmute(
    order_in_df,
    strand,
    tick_pos = (curr_end + next_start) / 2,
    tick_end = tick_pos + ifelse(strand == "+", 10, -10)
  )
# Plot
h <- 0.3 #box hight
p1 <- ggplot() +
  # introns
  geom_segment(data=distinct(exon_ranges2, order_in_df, gene.start, gene.end),
               aes(x=gene.start, xend=gene.end, y=order_in_df, yend=order_in_df),
               size=0.1, color = "grey40") +
  # positive or neg strand arrow ticks
  geom_segment(data=tick_df,
               aes(x=tick_pos, xend=tick_end, y=order_in_df, yend=order_in_df),
               arrow=arrow(length=grid::unit(0.1,"lines"), type="closed"),
               color = "grey40") +
  # exon rectangles
  geom_rect(data=exon_ranges2,
            aes(xmin=start, xmax=end, ymin=order_in_df-h, ymax=order_in_df+h, fill=transcript_biotype),
            color = "gray40", size = 0.1) +
  ## UTR rectangles
  geom_rect(data=exon_rangesutr,
            aes(xmin=start, xmax=end, ymin=order_in_df-h, ymax=order_in_df+h, alpha = "UTR"), 
            fill = "gray95", color = "gray40", size = 0.1) +
  scale_y_continuous(breaks=unique(exon_ranges$order_in_df),
                     labels=unique(exon_ranges$transcript_id)) +
  scale_fill_manual(values = c(
    unprocessed_pseudogene = "#702082",
    protein_coding = "#00274C",
    retained_intron = "#2F65A7",
    nonsense_mediated_decay = "#00B2A9",
    `protein_coding;MANE_tag` = "#FFCB05"
  )) +
  scale_alpha_manual(
    name = NULL, 
    values = c(UTR = 1),  # full opacity
    guide  = guide_legend(override.aes = list(fill= "gray95", color= "gray40", alpha= 1, size= 0.1 ))
  ) +
  theme_minimal() +
  theme(
    # legend.position = "none",
    axis.title.y = element_blank(),
    axis.line.x = element_line(linewidth = 0.25),
    axis.ticks.x = element_line(linewidth = 0.25),
    panel.grid = element_blank()
  )+
  xlab("chr6 coordinate (hg38 / Ensembl release-112)")
p1

## now zoooooom in on the target sequence: first split to bases and positions
# set new zoom coordinates 
zoom.min <- upstream
zoom.max <- downstream
yzoom <- exon_ranges$order_in_df[which(exon_ranges$tag == "MANE_Select")][1]

full_seq   <- as.character(subseq(chr6, upstream, downstream))
bases <- strsplit(full_seq, "")[[1]]
positions <- upstream:downstream
seq_df <- data.frame(pos = positions-.5, base = bases, stringsAsFactors = FALSE)

gg<- ggplot(seq_df, aes(x = pos, y = 1, label = base, colour = base)) +
  annotate("rect", xmin = hit.start-1, xmax = hit.end, 
           ymin = 0.8, ymax = 1.2, fill = "#628395", alpha = 0.2) +
  geom_text(size = 3, fontface = "bold") +
  scale_colour_manual(values = c(A = "forestgreen", C = "#00A5CF", G = "firebrick", T = "#FE6900") ) +
  scale_y_continuous(expand = expansion(0)) +
  scale_x_continuous(name = "chr6 (hg38) coordinate",
                     breaks = seq(from = upstream, to = downstream, length.out = 5)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank(),
    panel.grid = element_blank()
  )+
  coord_cartesian(xlim = c(zoom.min, zoom.max)) #zooming on this area

p2 <- p1+ coord_cartesian(xlim = c(zoom.min, zoom.max), ylim = c(yzoom-2.5, yzoom+.5)) #zooming on this area
cowplot::plot_grid(gg, NULL, p2, ncol = 1, rel_heights = c(1, -0.3, 3), align = "v", axis = "bt")


#------ Fig. 5d & 5e ------#
DimPlot_scCustom(seu, group.by = "malignant", reduction = "umap", pt.size=0.4, shuffle = T, seed = 100) +scale_color_manual(values= pal_malig, drop=F) # drop=F to show a level in legend even if it is unused in the plot (4in x 6in)

```

## Suppl.Fig.S1
# detecting TP53 and IDH1 mutations in short reads

```{r}

### Details in a separate notebook: "AML1_Bash_and_R_analysis_shortread_mutations.Rmd" ###

```

## Suppl.Fig.S2 
# getting mm2 defaults, with examples

```{r}

## Visualize minimap2 thresholds  

#------ Suppl.Fig.S2a ------#

## Do this for each sample in your cohort, then save the 'mm2_dfs' file on your computer
#map with the genotypes found in the seurat object
ctsu <- cts[["mRNA"]]
special <- "[_*|?.+$^]"
ctsu$gene0 <- gsub(special, "-", ctsu$gene)
ctsu[c("hla", "leftover")] <- str_split_fixed(ctsu$gene, special, 2)
ctsu$leftover <- NULL
#rev comp CBs for 3prime on PacBio
# ctsu$CB <- pbmcapply::pbmclapply(ctsu$CB, function(x) intToUtf8(rev(utf8ToInt(chartr('ATGC', 'TACG', x)))), mc.cores = 1) %>% unlist()
ctsu$genotype <- NA
ctsu$seu_barcode <- paste0(ctsu$samp,"_",ctsu$CB,"-1")
ctsu$seu_barcode %in% colnames(seu) %>% table()
ctsu$seu_barcode %in% colnames(seu) %>% table() / dim(ctsu)[1]
ctsu$genotype <- seu$geno[match(ctsu$seu_barcode, colnames(seu))]

## next, write this function that will be used in ggplot
median.quartile <- function(x){
  out <- quantile(x, probs = c(0.25,0.5,0.75))
  names(out) <- c("ymin","y","ymax")
  return(out)
}

genes <- c(rp, dn)
mm2_dfs <- data.frame(id=character(), hla=character(), allele.of=character(), s1_belowmax=numeric(), AS_belowmax=numeric(), NM_thresh=numeric(), de_thresh=numeric())
for (i in seq_along(genes)) {
  sub.cts <- ctsu[ctsu$gene == genes[i],] %>% tidyr::drop_na(genotype)
  mm2 <- c("s1", "AS", "NM", "de")
  mm2_df <- data.frame(id= substr(samples[1],1,nchar(samples[1])-3),
                       hla=unique(sub.cts$hla), 
                       allele.of=ifelse(genes[i] %in% rp, "Recipient", ifelse(genes[i] %in% dn, "Donor", "Shared/Homoz")), 
                       s1_belowmax=NA, 
                       AS_belowmax=NA, 
                       NM_thresh=NA, 
                       de_thresh=NA)
  for (m in seq_along(mm2)) {
    thresh <- seq(min(sub.cts[,mm2[m]]), max(sub.cts[,mm2[m]]), length.out = 100)
    best_Ct <- NULL
    best_sens <- 0
    best_spec <- 0
    if (genes[i] %in% rp) {
      geno <- c("Donor", "Recipient")
    } else if (genes[i] %in% dn) {
      geno <- c("Recipient", "Donor")
    } else {stop("'geno' must be among Donor-sepcific or Recipient-specific genotypes")}
    for (Ct in thresh) {
      if (m %in% c(3,4)){
        predict <- ifelse(sub.cts[,mm2[m]] >= Ct, geno[1], geno[2])
      } else {
        predict <- ifelse(sub.cts[,mm2[m]] <= Ct, geno[1], geno[2])
      }
      predict <- factor(predict, levels = unique(sub.cts$genotype %>% sort()))
      conf.mtx <- table(predict, sub.cts$genotype) 
      sens <- conf.mtx["Donor", "Donor"] / sum(conf.mtx[ ,"Donor"])
      spec <- conf.mtx["Recipient", "Recipient"] / sum(conf.mtx[ ,"Recipient"])
      if (sens+spec > best_sens+best_spec) {
        best_Ct <- Ct
        best_sens <- sens
        best_spec <- spec
      }
      if (m %in% c(1,2)) {
        best_Ct_belowmax <- best_Ct/max(sub.cts[,mm2[m]])
        mm2_df[ ,m+3] <- best_Ct_belowmax
      } else {
        best_Ct_belowmax <- NULL
        mm2_df[ ,m+3] <- best_Ct
      }
    }
  }
  mm2_dfs <- rbind(mm2_dfs, mm2_df)
}
# write.csv(mm2_dfs, file.path(DATA_DIR, "mm2_thresholds-best_sens_spec.csv"), row.names=FALSE)

## now you can download the file at will
mm2_dfs <- data.table::fread(file.path(DATA_DIR, "mm2_thresholds-best_sens_spec.csv"), header = T, sep=",")

colnames(mm2_dfs)[4:5] <- c("s1_percent_pass_score", "AS_percent_pass_score")
mm2_dfs$s1_percent_pass_score <- (mm2_dfs$s1_percent_pass_score)*100
mm2_dfs$AS_percent_pass_score <- (mm2_dfs$AS_percent_pass_score)*100
g <- c()
for (l in 4:7) {
  p <- ggplot(mm2_dfs, aes(x= hla, y= .data[[colnames(mm2_dfs)[l]]]))+
  geom_violin(trim = T)+
  geom_hline(yintercept = mean(mm2_dfs[[colnames(mm2_dfs)[l]]]), linetype= "dashed", color= "purple", linewidth= 0.5, alpha= 0.5)+
  ylim(c(0,max(mm2_dfs[[colnames(mm2_dfs)[l]]])))+
  theme_minimal()+
  stat_summary(fun = "mean",
               geom = "crossbar", 
               width = 0.5,
               colour = "red")+
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
    axis.title.x = element_blank()
  )
  g <- c(g, list(p))
}

patchwork::wrap_plots(g, ncol = 1, axes = "collect_x") # 5x5 in

#------ Suppl.Fig.S2b ------#

## verify those cutoffs in examples
i <- 1 # chose position in object 'genes'
p <- ggplot(ctsu[ctsu$gene == genes[i],], aes(x= genotype, y=s1, fill=genotype))+ 
  geom_violin(trim = T)+
  geom_hline(yintercept = 0.8*max(ctsu[ctsu$gene == genes[i],]$s1), linetype= "dashed", color= "black", linewidth= 0.5, alpha= 0.5)+ 
  #ylim(c(-1000,0))+
  stat_summary(fun.data = median.quartile, fill="white", geom = "crossbar", width=0.075, alpha=0.5)+
  labs(title = paste0(genes[i], " (", ifelse(genes[i] %in% rp, "Recip-spec", ifelse(genes[i] %in% dn, "Donor-spec", "Shared/Homoz")), ")"))+
  theme(
    # axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), 
    legend.position = "none",
    axis.title.x = element_blank()
  ) +

ggplot(ctsu[ctsu$gene == genes[i],], aes(x= genotype, y=AS, fill=genotype))+ 
  geom_violin(trim = T)+
  geom_hline(yintercept = 0.8*max(ctsu[ctsu$gene == genes[i],]$AS), linetype= "dashed", color= "black", linewidth= 0.5, alpha= 0.5)+ 
  #ylim(c(-1000,0))+
  stat_summary(fun.data = median.quartile, fill="white", geom = "crossbar", width=0.075, alpha=0.5)+
  labs(title = paste0(genes[i], " (", ifelse(genes[i] %in% rp, "Recip-spec", ifelse(genes[i] %in% dn, "Donor-spec", "Shared/Homoz")), ")"))+
  theme(
    # axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), 
    legend.position = "none",
    axis.title.x = element_blank()
  )  +
  
ggplot(ctsu[ctsu$gene == genes[i],], aes(x= genotype, y=NM, fill=genotype))+ 
  geom_violin(trim = T)+
  geom_hline(yintercept = 15, linetype= "dashed", color= "black", linewidth= 0.5, alpha= 0.5)+ 
  #ylim(c(-1000,0))+
  stat_summary(fun.data = median.quartile, fill="white", geom = "crossbar", width=0.075, alpha=0.5)+
  labs(title = paste0(genes[i], " (", ifelse(genes[i] %in% rp, "Recip-spec", ifelse(genes[i] %in% dn, "Donor-spec", "Shared/Homoz")), ")"))+
  theme(
    # axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), 
    legend.position = "none",
    axis.title.x = element_blank()
  ) +

ggplot(ctsu[ctsu$gene == genes[i],], aes(x= genotype, y=de, fill=genotype))+ 
  geom_violin(trim = T)+
  geom_hline(yintercept = 0.01, linetype= "dashed", color= "black", linewidth= 0.5, alpha= 0.5)+ 
  #ylim(c(-1000,0))+
  stat_summary(fun.data = median.quartile, fill="white", geom = "crossbar", width=0.075, alpha=0.5)+
  labs(title = paste0(genes[i], " (", ifelse(genes[i] %in% rp, "Recip-spec", ifelse(genes[i] %in% dn, "Donor-spec", "Shared/Homoz")), ")"))+
  theme(
    # axis.text.x = element_text(angle = 45, vjust = 1, hjust=1), 
    # legend.position = "none",
    axis.title.x = element_blank()
  )  + patchwork::plot_layout(nrow = 1) #3x12 in
print(p)

```

## Suppl.Fig.S3 and Suppl.Fig.S4 
# Molecular Swap

```{r}

#------ Suppl.Fig.S3b, S3c, S4b, or S4c------#
## map with the genotypes found in the seurat object
ctsu <- cts[["mRNA"]]
special <- "[_*|?.+$^]"
ctsu$gene0 <- gsub(special, "-", ctsu$gene)
ctsu <- data.table::setDF(ctsu) #interesting that the below code works if data.frame not data.table
ctsu[c("hla", "leftover")] <- stringr::str_split_fixed(ctsu$gene, special, 2)
ctsu$leftover <- NULL
print("Available reads per gene", quote=F)
print(table(ctsu$hla, useNA = "ifany"))
ctsu$genotype <- NA
ctsu$seu_barcode <- paste0(ctsu$samp,"_",ctsu$CB,"-1")
ctsu$seu_barcode %in% colnames(seu) %>% table()
ctsu$seu_barcode %in% colnames(seu) %>% table() / dim(ctsu)[1]
ctsu$genotype <- seu$geno[match(ctsu$seu_barcode, colnames(seu))]
ctsu$cbumi <- paste0(ctsu$CB, ":", ctsu$UMI)
table(ctsu$genotype, ctsu$hla, useNA = "ifany")
unique(ctsu$hla)

# write fasta, only once, and save it in your data directory
cts.fa<- ctsu
special <- "[_*|?.+$^]"
cts.fa$gene0 <- gsub(special, "-", cts.fa$gene)
cts.fa$header <- paste0("> ", cts.fa$cbumi, " mapping to ", cts.fa$gene0)
cts.fa$sequence <- paste0(cts.fa$seq)
cts.fa <- cts.fa[, c("header", "sequence")]
fasta <- "HLA_of_AML401.fa"          #change every time
write.table(cts.fa, file.path(DATA_DIR, fasta), quote=FALSE, sep='\n', col.names = F, row.names = F)

# align the fasta file and a few examples of identical CB:UMI with deferent sequences and called differently by mm2!
align <- readDNAStringSet(file.path(DATA_DIR, fasta))
ref_align <- readDNAStringSet(file.path("~/develop/scrHLAtag/data/HLA_DB_3field_mRNA.fa.gz")) # mRNA alignment
#ref_align <- readDNAStringSet(file.path("~/develop/scrHLAtag/data/HLA_DB_3field_gene.fa.gz")) # genomic alignment

# align 2 related alleles to see the difference
gn <- cts[["mRNA"]]$gene %>% unique() %>% sort()
gn <- gsub(special, "\\|", gn)
gn <- gsub(paste0("(", "\\|", ")"), paste0("\\\\", "\\1"), gn, perl=T)
gn
examples <- c("CACAGTAGTACGCACC:TCGACAAGCA", #1
              "CTGTTTAAGCATCATC:AACAACACAG", 
              "CCCAATCCATGAAGTA:TTTCTACACC",
              "CTCTAATTCGCCATAA:TCTACGCTTA",
              "GACTAACGTTATCGGT:GCGATCCGCT", #5
              "AACTCCCAGGTGCAAC:TTATTCAGCA",
              "TGACTTTTCATCGCTC:TGCATTTCAT",
              "AAAGTAGAGTGTTAGA:CGATATGGCA",
              "GCGCGATTCCCAGGTG:TAGCTGTCAT",
              "GATCAGTCAAGTAGTA:GCCGCACGTG", #10
              "AGGCCACTCTACGAGT:CACGCTCTAC",
              "CGGCTAGTCTTAACCT:CACACTGCTT",
              "TCTTCGGTCGGAATCT:ACCTTGCGGT") 
# example of clear molecular swap between HLA-A and HLA-B in AML4_90d
ra1 <- ref_align[ref_align@ranges@NAMES %like% gn[3]] 
ra2 <- ref_align[ref_align@ranges@NAMES %like% gn[4]]
BrowseSeqs(AlignSeqs(c(ra1, align[align@ranges@NAMES %like% examples[5]], ra2), verbose = F), highlight=0, colWidth = 200, colorPatterns = F)

#------ Suppl.Fig.S3d ------#
# aggregate molecular swap data shown from running 'HLA_matrix()' on many 5' and 3' HLA captures, save them in .csv

## molecular swap rates
mol_swap <- data.table::fread(file.path("/fh/fast/furlan_s/user/skanaan/scrHLAtyping/Manuscript/Mol_swap_rates.csv"), header = T, sep=",")
mol_swap <- reshape2::melt(mol_swap, id.vars = c("ID", "10x Chemistry", "total_swap"),
                           variable.name = "swap_type", 
                           value.name = "frequency")

ggplot(mol_swap, aes(y= swap_type, x= frequency, fill= `10x Chemistry`))+
  geom_jitter(aes(color= `10x Chemistry`))+
  ggbreak::scale_x_break(c(0.015, 0.04), scales = 0.5)+
  theme_cowplot()+
  theme(
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
    axis.title.y = element_blank()
  ) # 3x12in landscape

```

## Suppl.Fig.S6 
## 3prime RNA, Multiome, vs. 5prime RNA

```{r}
## load pre-aggregated data, previously collected using 'HLA_Matrix()' with arg 'return_stats = TRUE'
perstep_stats <- data.table::fread(file.path(DATA_DIR, paste0("AML1_per_step_stats-iter4.csv")), header = T, sep=",")
umi_dupl <- data.table::fread(file.path(DATA_DIR, paste0("AML1_umi_dupl-iter4.csv")), header = T, sep=",")

perstep_stats <- mutate(perstep_stats, step = case_when(
  step == "0_raw_reads" ~ "0_Starting counts",
  step == "1_qc_mm2" ~ "1_1st Corr. (step 1)",
  step == "3_dedup" ~ "3_Dedup (step 3)",
  step == "7_ld_correct" ~ "7_Final Corr. (step 7)",
  TRUE ~ step # to keep the rest unchanged
))

#------ Suppl.Fig.S6a ------#
ggplot(umi_dupl, aes(x= rank, y=n_umi, color = sample))+
  #geom_smooth(size=2, method = "gam")+
  geom_line(linewidth = 0.75)+
  scale_y_log10(name = "PCR copies per UMI")+
  scale_x_continuous(name = "Rank (nth UMI)", n.breaks = 8) +
  annotation_logticks(sides = "l", outside = F, short = unit(0.75,"mm"), mid = unit(0.75,"mm"), long = unit(1.5,"mm"), size = 0.25)+
  theme_cowplot()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+scale_color_manual(values=pal5) # 3x7in

#------ Suppl.Fig.S6b ------#
ggplot(perstep_stats[perstep_stats$step %in% c("0_Starting counts", "1_1st Corr. (step 1)", "3_Dedup (step 3)", "7_Final Corr. (step 7)"),], aes(x= step, y= reads))+
  geom_bar(stat="identity", position=position_dodge(), alpha= 1)+
  scale_y_continuous(name = "number of sequenced reads", 
                     #trans= "log2",
                     n.breaks = 8)+
  scale_x_discrete(label=function(x) sub('..', '', x),
                   name = "HLA_matrix() steps")+
  facet_grid(~ sample)+ 
  theme_classic(14)+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) #4x6in

#------ Suppl.Fig.S6c ------#
ggplot(perstep_stats[perstep_stats$step %in% c("0_Starting counts", "1_1st Corr. (step 1)", "3_Dedup (step 3)", "7_Final Corr. (step 7)"),], aes(x= step, y= cb_seu_match_rate))+
  geom_bar(stat="identity", position=position_dodge(), alpha= 1)+
  scale_y_continuous(name = "rate of CBs matching in Seurat", 
                     #trans= "log2",
                     n.breaks = 8)+
  scale_x_discrete(label=function(x) sub('..', '', x),
                   name = "HLA_matrix() steps")+
  facet_grid(~ sample)+ 
  theme_classic(14)+theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) #4x6in

```

## Suppl.Fig.S7 
# HLA pattern-based classification of cells (HLA UMAPs)
# HLA pattern-based classification agreement with souporcell

```{r}
#------ Suppl.Fig.S7a & S7b ------#

HLA_umap <- HLA_clusters(reads = cts[["mRNA"]], 
                         k = 2, 
                         cell_data_obj = seu,
                         # CB_rev_com = T,  # TRUE for 3prime 10x on pacbio
                         geno_metadata_id = "geno", 
                         method = "consensus",
                         seed = NULL, suppress_plots = T,
                         spread = 5, min_dist = 0.001, repulsion_strength = 0.001)
HLA_umap[[2]]+scale_color_manual(values=c("#b2df8a", "#ff7f00"))+theme_classic()
HLA_umap[[3]]+scale_color_manual(values=c("grey65", "red"))+theme_classic()

### Repeat this HLA_clusters() function on any counts file from scrHLAtag to get the classifications from "in between" iterations as well

```

## Suppl.Fig.S9
## False positive rates as a function of Chimerism proportion

```{r}

#------- Suppl.Fig.S9 ------# 
## run this for multiple samples, not just the ones in this example
{
  Idents(seu)<-seu$geno
  levels(Idents(seu))
  fpr_df <- pr_exp[pr_exp$AlleleOrigin %in% c("donor", "recipient"),]
  fpr_df$FPR <- ifelse(fpr_df$AlleleOrigin == "donor", 
                       fpr_df[,which.max(stringdist::stringdist("donor", paste0("frac_", levels(Idents(seu))), method = "lv"))], 
                       fpr_df[,which.min(stringdist::stringdist("donor", paste0("frac_", levels(Idents(seu))), method = "lv"))])
  fpr_df <- fpr_df[,c("AlleleOrigin", "Alleles", "FPR")]
  fpr_df$Pr_Chim <- ifelse(fpr_df$AlleleOrigin == "donor", 
                           length(colnames(seu[ , rownames(seu@meta.data)[
                             seu@meta.data$geno == levels(Idents(seu))[
                               which.min(stringdist::stringdist("donor", levels(Idents(seu)), method = "lv"))
                             ]
                           ]]))/length(colnames(seu)), 
                           length(colnames(seu[ , rownames(seu@meta.data)[
                             seu@meta.data$geno == levels(Idents(seu))[
                               which.max(stringdist::stringdist("donor", levels(Idents(seu)), method = "lv"))
                             ]
                           ]]))/length(colnames(seu))
  )
  prefx <- substr(colnames(seu), 1, nchar(colnames(seu)) - sapply(base::gsub(".*[ATGC]+(.*)$", "\\1", colnames(seu)), nchar))
  prefx <- substr(prefx, 1, sapply(base::gregexpr("[^A-Za-z0-9]", prefx), function(pos) if (max(pos)>0) max(pos) else 0))
  separator <- sapply(prefx, function(x) substr(x, nchar(x), nchar(x)))
  sampls <- substr(prefx, 1, nchar(prefx) - sapply(separator, nchar))
  fpr_df$subject <- substr(unique(sampls)[1],1,nchar(unique(sampls)[1])-3)
  if (exists("fpr_dfs")) {fpr_dfs <- rbind(fpr_dfs, fpr_df)} else {fpr_dfs <- fpr_df}
  rm(fpr_df)
}

## ...or, retrieve this file
fpr_dfs <- data.table::fread(file.path("/fh/fast/furlan_s/user/skanaan/scrHLAtyping/WorkFlowTest_AML401/_R_ANALYSES/data/FPR_v_ChimProp.csv"), header = T, sep=",")

ggplot(fpr_dfs, aes(x=1-Pr_Chim, y=FPR))+
  geom_jitter(width=0.02, height=0, alpha = 0.25, size = 3) +
  geom_hline(yintercept = mean(fpr_dfs[["FPR"]]), linetype= "dashed", color= "purple", linewidth= 0.5, alpha= 1)+
  scale_y_continuous(name= paste("False Pos Rate"))+
  scale_x_continuous(name= paste("Proportion Chimerism"))+
  geom_text(aes(x = 0, y = mean(fpr_dfs[["FPR"]]), label = round(mean(fpr_dfs[["FPR"]]),4)), color = "purple", hjust = 1.5) + 
  coord_cartesian(clip = 'off')+
  theme_cowplot() # 5 x 4 in

```

## Suppl.Fig.S10
# malignant cell identification

```{r}
#------ Suppl.Fig.S10a ------#
## souporcell and viewmaster data have been previously calculated as described 
## in https://furlan-lab.github.io/viewmastR/
## and stored in the 'geno' and 'celltype' metadata columns of the 
## Seurat object (see also the "Seurat_Assemble" example workflow)
DimPlot_scCustom(seu, group.by = "celltype", colors_use = bmcolsl, pt.size = 0.4)
DimPlot_scCustom(seu, group.by = "geno", label = F, pt.size = 0.1,order = sort(unique(seu$geno), decreasing = T))+scale_color_manual(values=c("grey65", "red"))

# split by souporcell
DimPlot_scCustom(seu, group.by = "celltype", colors_use = bmcolsl, split.by = "geno", pt.size = 0.4)

#------ Suppl.Fig.S10b ------#
## construct plots p1, p2, p3, p4, p5, and p6 with all 3 time-point captures of AML4 (days 90, 140, 163) 
## and for each souporcell genotype

soup <- 1 # soup 1 and 2 for each AML4 timepoints, loaded separately into a new 'seu' object
seu_sub <- seu[ , rownames(seu@meta.data)[seu@meta.data$geno == sort(unique(seu@meta.data$geno))[soup]]]
tab <- data.frame(table(seu$celltype, seu$geno))
p1 <- ggplot(subset(tab, Var2 == sort(unique(seu@meta.data$geno))[soup]), aes(x="", y=Freq, fill=Var1))+
  geom_bar(stat="identity") +
  # geom_bar(stat="identity", width=1, color="white") +
  # coord_polar("y", start=0) +
  theme_void() +
  labs(fill="cell type") +
  # geom_text(aes(label=paste0(format(round(Freq/sum(subset(tab, Var2 == sort(unique(seu@meta.data$geno))[soup])$Freq), 3), nsmall = 1))), position=position_stack(vjust=0.5))+
  scale_fill_manual(values=bmcolsl) +theme(legend.position = "none")

layout <- "
ABC#DFG
"
# plot <- p1 + p3 + p5 + p2 + p4 + p6 + patchwork::plot_layout(design = layout)
# saveRDS(plot, file.path(DATA_DIR, "celltype_composition_AML40123.RDS"))
plot <- readRDS(file.path(DATA_DIR, "celltype_composition_AML40123.RDS"))
DimPlot(seu, group.by = "celltype", cols = bmcolsl, split.by = "geno") /plot # 5x7 in then scale down to 75%

#------ Suppl.Fig.S10c ------#


## select malignant cells based on seurat clusters, not viewmaster classes
## and check if they manifest 'stemness' or 'immortal' properties

pl <- DimPlot(subset(x = seu, subset = geno == "Recipient"))
mal <- CellSelector(pl, object = NULL, ident = "malig")
seu$malignant <- NA
seu$malignant <- ifelse(seu$geno == "Recipient", "Rcp_Healthy", "Don_Healthy")
seu$malignant <- ifelse(colnames(seu) %in% mal, "Rcp_Malignant", seu$malignant)
Idents(seu)<-seu$malignant
old.lvl<-levels(Idents(seu)) %>% sort()
# old.lvl<- c("Rcp_Malignant", "Rcp_Healthy", "Don_Healthy") %>% sort() #in case you want to force specify the levels
seu$malignant <- factor(seu$malignant, levels = old.lvl)
seu@active.ident <- factor(seu@active.ident, levels = old.lvl)
levels(seu)
rm(old.lvl)
#display malignant cells
pal_malig <- c(Don_Healthy = "grey85", Rcp_Healthy = "red", Rcp_Malignant ="violetred4")
seu@active.ident
DimPlot_scCustom(seu, group.by = "malignant", reduction = "umap", pt.size=0.4, shuffle = T, seed = 100) +scale_color_manual(values= pal_malig, drop=F) # drop=F to show a level in legend even if it is unused in the plot (4in x 6in)


DefaultAssay(seu) <- "RNA"
Stacked_VlnPlot(seu, features = c("HOXA3", "HOXA4", "HOXA5", "HOXA7", "HOXA9", "HOXA10", "MEIS1"),
                x_lab_rotate = TRUE, split.by = "malignant", colors_use = c("grey85", "red", "violetred4", "black"), plot_legend =T) #supported by PMID: 23212154  DOI: 10.1038/leu.2012.356 

```

## Suppl.Fig.S11
# fusion detection in AML4 by long-read pulldown

```{r}

### Details in a separate notebook: "AML4d90_example_for_GeneFusion_workflow.Rmd" ###

```

## Suppl.Fig.S13
# in silico mixes with 3 or more chimeric entities

```{r}

### Details in a separate notebook: "insilico_mixes_withFigs.Rmd" ###

```

## Suppl.Fig.S14
# HLA pattern-based clustering accuracy as a function of the abundance of mismatched alleles between Recip and Donor

```{r}
#------- Suppl.Fig.S12 ------# 
## Running the HLA classifier
HLA_umap <- HLA_clusters(reads = cts[["mRNA"]], 
                         k = 2, 
                         cell_data_obj = seu,
                         # CB_rev_com = T,  # TRUE for 3prime 10x on pacbio
                         geno_metadata_id = "geno", 
                         method = "consensus",
                         seed = NULL, suppress_plots = T,
                         spread = 5, min_dist = 0.001, repulsion_strength = 0.001)


## do this for each sample in your cohort
tb <- table(HLA_umap[[1]]$hla_clusters, HLA_umap[[1]]$geno) %>% prop.table(. , margin = 1)
pred.val <- max(c(mean(c(tb[1,2], tb[2,1])), mean(c(tb[1,1], tb[2,2]))))
subj <- paste0(substr(samples[1],1,nchar(samples[1])-3), "-iter_", sub_d)
level.mm <- c(AML_101=2/34, AML_401=21/40, AML_402=21/40, AML_403=21/40, AML_601=6/37, AML_801=26/49, AML_1501=12/42)
df <- data.frame(sample=subj, rp.dn.pred.val=pred.val, MMlevel=level.mm[names(rds)[samp]])
rownames(df) <- NULL
rp.dn.pred.val <- c(rp.dn.pred.val, list(df))
rp.dn.predval <- do.call("rbind", rp.dn.pred.val)
write.csv(rp.dn.predval, file.path(DATA_DIR, "clustering_accuracy.csv"), row.names=FALSE)

##... or the previously saved data on Clustering accuracy in predicting correct allogeneic entities 
rp.dn.predval <- data.table::fread(file.path(DATA_DIR, "clustering_accuracy.csv"), header = T, sep=",")
ggplot(rp.dn.predval, aes(x= MMlevel, y= rp.dn.pred.val)) +
  geom_jitter(width=0.02, height=0, alpha = 0.25, size = 3) +
  geom_smooth(method =  "lm", #"lm", "glm", "gam", "loess" or MASS::rlm or mgcv::gam, stats::lm, stats::loess
              formula = y ~ log(x), alpha = 0.1, se =T, colour = "orange",linewidth= 1)+ 
  # geom_bin2d(bins = 25)+
  # geom_hex(bins = 25)+
  geom_hline(yintercept = 1, linetype= "dashed", color= "red", linewidth= 0.5, alpha= 0.5)+
  geom_hline(yintercept = 0.5, linetype= "dashed", color= "red", linewidth= 0.5, alpha= 0.5)+
  annotate("text", x= 0.15, y=1.015, label= "perfect accuracy", size = 3, color= "red") + 
  annotate("text", x= 0.15, y=.515, label = "random guess", size = 3, color= "red") +
  scale_y_continuous(name= paste("Consensus Algorithm Classification Accuracy"))+
  scale_x_continuous(name= paste("Frac of Mismatched over Total Alleles"))+
  # scale_fill_gradientn(#limits = c(0,1),       #set gradient limits or comment out to let it autoset
  #   colours = c("#00FF00", "#6A33C2"), 
  #   na.value = "grey35")+
  theme_classic() # 4 x 4.5 in

```

## Suppl.Fig.S15
## Sequence similarities in the reference library

```{r}

fasta <- "HLA_of_AML401.fa"          #change every time
align <- readDNAStringSet(file.path(DATA_DIR, fasta))
ref_align <- readDNAStringSet(file.path("~/develop/scrHLAtag/data/HLA_DB_3field_mRNA.fa.gz")) # mRNA alignment

## some alleles have longer sequences in the reference than the most common sequencing length, so mm2 will preferentially map reads to those as they will get better scores... what are they?
ref_length <- ref_align %>% as.data.frame()
ref_length[c("allele", "poop1", "length", "poop2")] <- stringr::str_split_fixed(rownames(ref_length), " ", 4)
ref_length[c("x", "poop1", "poop2")] <- NULL
rownames(ref_length) <- NULL
ref_length$allele <- gsub("\\|", "\\*", ref_length$allele)
ref_length$allele_grp <- stringr::str_split_fixed(ref_length$allele, ":", 2)[,1]
ref_length$hla_gene <- stringr::str_split_fixed(ref_length$allele_grp, "\\*", 2)[,1]
ref_length$length <- as.numeric(ref_length$length)
ref_length <- ref_length[ref_length$hla_gene %in% c("A", "B", "C", "E", "DPA1", "DPB1", "DQA1", "DQB1", "DRB1", "DRB3", "DRB4", "DRB5"),]
ggplot(ref_length, aes(x=length)) + 
  geom_histogram(binwidth=1) + 
  facet_wrap( ~ hla_gene, scales = "free") +
  ggthemes::theme_few()
ggplot(ref_length[ref_length$hla_gene %in% c("A"),], aes(x=length)) + 
  geom_histogram(binwidth=1) + 
  facet_wrap( ~ allele_grp, scales = "free") +
  ggthemes::theme_few()

get_top_modes <- function(v, n = 1) {
  uniqv <- unique(v)
  counts <- tabulate(match(v, uniqv))
  sorted_indices <- order(-counts)
  top_modes <- uniqv[sorted_indices][1:n]
  return(top_modes)
}
get_top_modes(ref_length[ref_length$hla_gene %in% c("A"),]$length, 4)
get_top_modes(ref_length[ref_length$allele_grp %in% c("DPA1*02"),]$length, 3)
ref_length$north.outlier <- NA
ref_length$length.diff <- NA
ref_length$length.diff <- ref_length$length.diff %>% as.numeric()
ref_length <- split(data.table::setDT(ref_length), by = "hla_gene")
ref_length <- lapply(ref_length, function(x){
  modes <- get_top_modes(x$length, 4)
  x$north.outlier <- ifelse(sapply(x$length, function(y){all(y-1 > modes)}), x$allele, NA)
  x$length.diff <- ifelse(sapply(x$length, function(y){all(y-1 > modes)}), x$length-max(modes), NA)
  return(x)
})
ref_length <- data.table::rbindlist(ref_length)
# how many outliers do we have?
sum(!is.na(ref_length$north.outlier)) # very manageable number!

#------ Suppl.Fig.S15 ------#

# after checking all outliers, we identified alleles to which PacBio reads 
# are highly likely to align instead of the true allele if they are in the ref
ra1 <- ref_align[ref_align@ranges@NAMES %like% "DPA1\\|02:38Q"]
ra2 <- ref_align[ref_align@ranges@NAMES %like% "DPA1\\|02:02:02"]
ra1 <- ref_align[ref_align@ranges@NAMES %like% "A\\|03:437Q"]
ra2 <- ref_align[ref_align@ranges@NAMES %like% "A\\|03:01:01"]
ra1 <- ref_align[ref_align@ranges@NAMES %like% "B\\|13:123Q"]
ra2 <- ref_align[ref_align@ranges@NAMES %like% "B\\|13:02:01"]
ra1 <- ref_align[ref_align@ranges@NAMES %like% "C\\|04:09L"]
ra2 <- ref_align[ref_align@ranges@NAMES %like% "C\\|04:01:01"]
ra1 <- ref_align[ref_align@ranges@NAMES %like% "C\\|04:61N"]
ra2 <- ref_align[ref_align@ranges@NAMES %like% "C\\|04:01:01"]
ra3 <- ref_align[ref_align@ranges@NAMES %like% "C\\|04:13:01"]
ra1 <- ref_align[ref_align@ranges@NAMES %like% "C\\|02:205Q"]
ra2 <- ref_align[ref_align@ranges@NAMES %like% "C\\|02:02:02"]
BrowseSeqs(AlignSeqs(c(ra1, ra2), verbose = F), highlight=0, colWidth = 220, colorPatterns = F)

```
