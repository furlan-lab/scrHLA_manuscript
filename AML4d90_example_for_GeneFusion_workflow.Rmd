---
title: "20250416_AML4_pbfusion_workflow_example"
author: "SBK"
date: "4/16/2025"
output: html_document
editor_options: 
  chunk_output_type: console
---

---
## SECTION 1: set up virtual environment for isoseq, do this once and you're all set!
## version 4.0.0 and above should work for Revio sequencing data; isoseq3 works for Sequel IIe data

```{bash}
##### Use OPTION+COMMAND+RETURN to send commands to 'Terminal' #####

export PATH=/home/skanaan/.conda/envs/isoseq/bin/python:$PATH
echo $PATH
ml fhPython/3.8.6-foss-2020b-Python-3.8.6 
ml Anaconda3/2022.05
ml SAMtools/1.11-GCC-10.2.0

conda create -n isoseq_v4 python=3 #skip this if already created

source activate isoseq_v4 

conda init zsh # restart your shell for changes to take effect, then reactivate isoseq and continue configuration
conda config --add channels defaults
conda config --add channels bioconda
conda config --add channels conda-forge
conda install -c bioconda lima
y
conda install -c bioconda isoseq
y
conda update -c bioconda isoseq
y
conda install -c bioconda pbaa
y
conda install -c bioconda pbbam
y
conda install -c bioconda pbcore
y
conda install -c bioconda pbfusion
y
conda install -c bioconda pbmarkdup
y
conda install -c bioconda pbskera
y
conda install -c bioconda pbsv
y
conda install -c bioconda pbpigeon
y
conda install -c bioconda pbmm2
y
conda install -c bioconda trgt
y
conda install -c bioconda pysam tqdm
y
conda install -c "conda-forge/label/cf201901" construct
y
conda install -c conda-forge argparse
y
conda install -c conda-forge gzip
y
conda install -c conda-forge r-sys
y
conda install -c bioconda structure
y
conda update --all
y

conda deactivate
## exit and restart Terminal session

```
## SECTION 2: Running IsoSeq pipline and pbfusion on PacBio targeted pulldown HiFi reads

```{bash}
##### Use OPTION+COMMAND+RETURN to send commands to 'Terminal' #####

#environment
export PATH=/home/skanaan/.conda/envs/isoseq/bin/python:$PATH
ml Anaconda3/2022.05
ml SAMtools/1.16.1-GCC-11.2.0
source activate isoseq_v4
# Check lima version, >= 2.6.0
lima --version
# Check isoseq version, >= 4.0.0
isoseq --version
# Check pbfusion and pbmm2 versions, the following pipeline and subsequent R code has been tested on pbfusion 0.5.0 (pbfusion=0.5.1=hdfd78af_0) and pbmm2 1.13.1 (pbmm2=1.13.1=h9ee0642_0)
pbfusion --version
pbmm2 --version

export ref_dir=/fh/fast/furlan_s/grp/refs/long_read_refs/pacbio
export data_dir=/fh/fast/furlan_s/SR/ngs/pacbio/221115_Sami/r64272e_20221115_203245
export out_dir=/fh/fast/furlan_s/grp/data/targ_reseq/03_longread_fusion_project/221115_PB_KMT2Afusion_juction_vs_tile
mkdir $out_dir
cd $out_dir

# 10x primer file
export primers_5p=$ref_dir/5p_10x_primers.fasta # 3p_10x_primers for 10x 3' and 5p_10x_primers for 10x 5' 
# 10x 737k barcode list (may need to be RC'd)
export cbc_include=/fh/fast/furlan_s/grp/refs/long_read_refs/pacbio/737K-august-2016.txt  # 5-prime 10x  v2
#export cbc_include=/fh/fast/furlan_s/grp/refs/long_read_refs/pacbio/3M-february-2018_rc.txt    # 3-prime 10x v3.1

# PacBio likes to use refs with no ALT contigs: regions too complex for a single representation (e.g. HLA); they can be highly divergent but most are nearly identical to primary assembly sequence. This may result in aligners (that are not ALT-aware) doing multi-mapping reads with mapping quality zero, thus reducing sensitivity of variant calling
export hg38=/fh/fast/furlan_s/grp/refs/long_read_refs/Human_hg38_Gencode_v39/human_GRCh38_no_alt_analysis_set.fasta
export annotation=/fh/fast/furlan_s/grp/refs/long_read_refs/Human_hg38_Gencode_v39/gencode.v39.annotation.sorted.gtf
# polyA sequences
export pA=$ref_dir/polyA.list
# cage peaks (Provides evidence of transcription start sites)
export cage=$ref_dir/refTSS_v3.1_human_coordinate.hg38.bed
export threads=24
# BAM files  MAKE SURE THEY ARE INDEXED
export BAM=${data_dir}/*/*/*hifi_reads*.bam
ls -asl $BAM

### isoseq ###
# lima: remove sequencing primers
# tag: separate UMI and CB from transcript; DONT FORGET: 5prime is 16B-10U-T and 3prime is T-12U-16B
# refine: trim the polyA seq
# correct: correct CB errors if any (if not already done by Skera when concatenated reads are processed)
# samtools sort: sort the corrected file by barcode
# bcstats: statistics for each barcode
# groupdedup: deduplicate molecules (replacing the older, slower isoseq dedup)

for ibam in $BAM; do
    export bam=$ibam
    in_dir=`dirname $bam`
    prefix=$in_dir/`basename $bam | cut -d'.' -f1`
    export prefix=${prefix/#"${data_dir}/"}
    export out_subdir=`dirname $prefix`
    mkdir -p $out_subdir
    sbatch -n 1 -c $threads -p campus-new -M gizmo --mem-per-cpu=21000MB --wrap='lima \
        --log-level INFO \
        --log-file $out_subdir/lima.log \
        --isoseq \
        -j $threads \
        $bam \
        $primers_5p \
        $prefix.bam &&
    isoseq tag \
        --log-level INFO \
        --log-file $out_subdir/tag.log \
        -j $threads \
        --design 16B-10U-T \
        $prefix.5p--3p.bam \
        $prefix.tagged.bam &&
    isoseq refine \
        --log-level INFO \
        --log-file $out_subdir/refine.log \
        -j $threads \
        --require-polya \
        $prefix.tagged.bam \
        $primers_5p \
        $prefix.refined.bam &&
    isoseq correct \
        --log-level INFO \
        --log-file $out_subdir/correct.log \
        -j $threads \
        --barcodes $cbc_include \
        $prefix.refined.bam \
        $prefix.corrected.bam &&
    samtools sort \
        -m 2G \
        -t CB \
        $prefix.corrected.bam \
        -o $prefix.corrected.sorted.bam &&
    isoseq bcstats --json $prefix.bcstats.json -o $prefix.bcstats.tsv $prefix.corrected.bam &&
    isoseq groupdedup \
        --log-level INFO \
        --log-file $out_subdir/dedup.log \
        -j $threads \
        -v \
        $prefix.corrected.sorted.bam \
        $prefix.dedup.bam'
done

squeue -u skanaan

### next, align to the genome then run PBFUSION ###

# #serialize gtf $annotation, needs to happen if file not present
# cd /fh/fast/furlan_s/grp/refs/long_read_refs/Human_hg38_Gencode_v39
# sbatch -n 1 -c 20 -p campus-new -M gizmo --mem-per-cpu=21000MB --wrap='
# pbfusion gff-cache \
#   --gtf $annotation \
#   --gtf-out $annotation.bin'
export annotation_serial=/fh/fast/furlan_s/grp/refs/long_read_refs/Human_hg38_Gencode_v39/gencode.v39.annotation.sorted.gtf.bin
# #compressing $annotation.bin (being substatially smaller, making artefact management much easier for pbfusion)
# xz -c -9 --extreme $annotation_serial > $annotation_serial.xz

# pbmm2: aligning reads to the reference genome in $hg38
# pbfusion discover: keep minimum fusion quality to emit at MEDIUM [default]. Other choice is LOW but will emit all events, even those not passing up to 5 quality tests
# pbfusion discover: setting `--log-level` to anything higher than WARN (e.g. INFO, DEBUG, TRACE) will also emit verbose output, including the extra output files.
for ibam in $BAM; do
    export bam=$ibam
    in_dir=`dirname $bam`
    prefix=$in_dir/`basename $bam | cut -d'.' -f1`
    export prefix=${prefix/#"${data_dir}/"/"${out_dir}/"}
    export out_subdir=`dirname $prefix`
    #checks if your input file(s) exist
    (ls $prefix.dedup.bam && echo yes) || echo no 
    (ls $annotation_serial.xz && echo yes) || echo no
    (ls $hg38 && echo yes) || echo no
    sbatch -n 1 -c $threads -p campus-new -M gizmo --mem-per-cpu=21000MB --wrap='
        pbmm2 align \
            --sort \
            --preset ISOSEQ \
            -j $threads \
            $hg38 \
            $prefix.dedup.bam \
            >$prefix.mapped.bam &&
        pbfusion discover \
            --gtf $annotation_serial.xz \
            --min-fusion-quality MEDIUM \
            --output-prefix $prefix.pbfusion.dedup.med \
            --log-level WARN \
            $prefix.mapped.bam'
done
squeue -u skanaan

conda deactivate

```

## SECTION 3: SETTING UP ENVIRONMENT in R

```{r}
graphics.off()
rm(list=ls())
knitr::opts_chunk$set(fig.width=8, fig.height=6,dpi=300,
                      echo=FALSE, warning=FALSE, message=FALSE)
knitr::opts_chunk$set(dev.args=list(bg="transparent"))
ROOT_DIR<-"/fh/fast/furlan_s/user/skanaan/scrHLAtyping"
stem<-"/WorkFlowTest_AML401/_R_ANALYSES"
DATA_DIR <- file.path(ROOT_DIR, stem, "data")   
RES_DIR  <- file.path(ROOT_DIR,  stem, "res")   
RMD_DIR  <- file.path(ROOT_DIR, stem, "rmd")     
CDS_DIR <- file.path(ROOT_DIR, stem, "cds")
FIG_DIR <- file.path(ROOT_DIR,  stem, "figs")

# dir.create(file.path(ROOT_DIR, stem))
# dir.create(DATA_DIR)
# dir.create(RES_DIR)
# dir.create(RMD_DIR)
# dir.create(CDS_DIR)
# dir.create(FIG_DIR)

suppressPackageStartupMessages({
  library(stringr)
  library(pbmcapply)
  library(parallel)
  library(Matrix)
  library(magrittr)
  library(htmltools)
  library(ggplot2)
  library(Seurat)
  library(dplyr)
  library(cowplot)
  library(Biostrings)
  library(data.table)
  library(IRanges)
  library(S4Vectors)
  library(uwot)
  library(gridExtra)
  library(tidyr)
  library(viridis)
  library(crayon)
  library(reticulate)
  library(viewmastR)
  library(scCustomize)
  library(Polychrome)
  library(ggh4x)
  library(muscat)
  # library(ComplexHeatmap)
  # library(scrubletR)
  # library(scrHLAmatrix)
})
options(warn=-1) #to suppress warnings globaly. options(warn=0) to get them back

## color palette
bmcols <- viewmastR::sfc(16)[c(1:3, 5:16)]
names(bmcols)<-c("01_HSC", "02_Early_Erythroid","03_Late_Erythroid","04_Myeloid_Progenitor","05_Lymphoid_Progenitor","06_pDC","07_cDC","08_CD14_Monocyte","09_CD16_Monocyte","10_Other","11_Pre_B","12_B", "13_Plasma","14_T" ,"15_NK")
data(palette36)
palette36 <- unname(palette36)
c25 <- c("dodgerblue2", "#E31A1C", "green4", "#6A3D9A","#FF7F00", "black", "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1", "blue1", "steelblue4", "darkturquoise", "green1", "yellow4", "yellow3", "darkorange4", "brown")


```
## SECTION 4: VISUALIZE KMT2A FUSIONS in AML4

```{r}
## Note: you can reconstruct any Seurat object from the barcodes.tsv, metadata.csv, features.tsv, and matrix.mtx files available in GEO
expr_matrix <- readMM(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_RNA_matrix.mtx.gz"))
rownames(expr_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_RNA_features.tsv.gz"), header=F)$V1
colnames(expr_matrix) <- fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_barcodes.tsv.gz"), header=F)$V1
metadata <- data.frame(fread(file.path(CDS_DIR, "AML4_d90_merged_Seurat_QCed_metadata.csv"), header=T), row.names=1)
seu <- CreateSeuratObject(counts = expr_matrix, project = "AML4_d90")
#make sure the metadata barcodes are the same as the seu barcodes
identical(metadata, metadata[colnames(seu), , drop = F])
seu <- AddMetaData(seu, metadata)
#retrieve umap backup coordinates from metadata
umap <- seu@meta.data[,c("UMAP_1_backup","UMAP_2_backup")]
colnames(umap) <- c(1,2)
seu$umap <- CreateDimReducObject(embeddings = as.matrix(umap), key = "umap_", assay = "RNA")
rm(expr_matrix, metadata, umap)

## samples in Seu object (in a way agnostic of what prefix or whether there is a prefix, separator, and/or suffix in the seurat barcode)
seu_cb <- data.frame(seu_cb=colnames(seu))
rownames(seu_cb) <- seu_cb$seu_cb
seu_cb$prefx <- substr(seu_cb$seu_cb, 1, nchar(seu_cb$seu_cb) - sapply(base::gsub(".*[ATGC]+(.*)$", "\\1", seu_cb$seu_cb), nchar))
seu_cb$prefx <- substr(seu_cb$prefx, 1, sapply(base::gregexpr("[^A-Za-z0-9]", seu_cb$prefx), function(pos) if (max(pos)>0) max(pos) else 0))
seu_cb$sepr <- sapply(seu_cb$prefx, function(x) substr(x, nchar(x), nchar(x)))
seu_cb$prefx <- substr(seu_cb$prefx, 1, nchar(seu_cb$prefx) - sapply(seu_cb$sepr, nchar))
seu_cb$naked_cb <- unlist(lapply(seu_cb$seu_cb, function(x) intToUtf8(rev(utf8ToInt(x)))))
seu_cb$naked_cb <- gsub("^[^ATGC]*([ATGC]+).*", "\\1", seu_cb$naked_cb)
seu_cb$naked_cb <- unlist(lapply(seu_cb$naked_cb, function(x) intToUtf8(rev(utf8ToInt(x)))))
seu_cb$sufx <- base::gsub(".*[ATGC]+(.*)$", "\\1", seu_cb$seu_cb)
seu_cb$seu_cb <- NULL
table(rownames(seu_cb) == paste0(seu_cb$prefx, seu_cb$sepr, seu_cb$naked_cb, seu_cb$sufx)) # check if Seurat barcode dissection was correctly made
samples <- unique(seu_cb$prefx)

## directories where pbfusion was run
dirs_path <- "/fh/fast/furlan_s/grp/data/targ_reseq/03_longread_fusion_project/221115_PB_KMT2Afusion_juction_vs_tile"
dirs<-list.dirs(path=dirs_path, full.names = T, recursive = F)
dirs<- lapply(dirs, list.dirs, recursive = F) %>% unlist
#do you have somewhere in your notes which directory is for which sample of your Seurat object?
#here, the 1st and 2nd directories correspond to samples in Seu:
dirs <- dirs[c(1,2)]
names(dirs) <- c(samples[2], samples[1]) #watch out for name ordering

## load fusion bed files
ct <- lapply(1:length(dirs), function(y) {
  #y <- 2
  smpl <- names(dirs)[y]
  files <- list.files(dirs[y]) 
  bedfile <- "\\.pbfusion.dedup.med.breakpoints.groups.bed$" # tweak according to pbfusion output
  ct<-read.table(file.path(dirs[y], files[grep(bedfile, files)]))
  # Function to extract fusion gene names from the V11 column using tag GN=
  getFusionGenes <- function(info_string) {
    # Split the string on semicolons to extract tags
    tags <- unlist(strsplit(info_string, ";"))
    # Look for the tag that starts with "GN="
    gn_tag <- tags[grep("^GN=", tags)]
    if (length(gn_tag) == 0) return(NA)
    # Remove the "GN=" prefix and split by commas
    genes <- unlist(strsplit(sub("^GN=", "", gn_tag), ","))
    # Create a fusion name by joining the genes with an underscore
    fusion_name <- paste(genes, collapse = "_")
    return(fusion_name)
  }
  # Function to extract fusion count from the V11 column using tag BP=
  getFusionCount <- function(info_string) {
    tags <- unlist(strsplit(info_string, ";"))
    bp_tag <- tags[grep("^BP=", tags)]
    if (length(bp_tag) == 0) return(1)
    count_val <- as.numeric(sub("^BP=", "", bp_tag))
    return(count_val)
  }
  # Add fusion gene names and count columns to the dataframe
  ct$fusion <- sapply(ct$V11, getFusionGenes)
  ct$count  <- sapply(ct$V11, getFusionCount)
  ct$sample <- smpl #add the Seurat sample here, it will be useful later
  return(ct)
})
ct <- do.call(rbind, ct)

## Set up the circular plot.
simple_ct <- ct[, colnames(ct)[!(colnames(ct) %in% c("V7", "V8", "V9", "V10", "V11", "V12", "sample"))]]
simple_ct <- simple_ct[order(simple_ct$fusion), ]
rownames(simple_ct) <- NULL
simple_ct <- simple_ct %>% #collapsing similar rows into a single row and adding `count`
  group_by(V1, V2, V3, V4, V5, V6, fusion) %>%
  summarise(count = sum(count), .groups = "drop") %>% as.data.frame()
simple_ct <- simple_ct[order(-simple_ct$count), ]

#library(circlize)
circlize::circos.clear()  # clear previous plots/settings
par(ljoin = 2) #0 or "round" (default), 1 or "mitre" and 2 or "bevel". change if the thicker the line the uglier round edges become
circlize::circos.par(gap.degree = 2)   # adjust gap between the chromosomal sectors if desired
circlize::circos.initializeWithIdeogram(species = "hg38")
scaling_factor <- 0.05 # for line widths, adjust as needed
circlize::circos.genomicLink(region1 = simple_ct[, c("V1", "V2", "V3")],
                             region2 = simple_ct[, c("V4", "V5", "V6")],
                             lwd = simple_ct$count * scaling_factor,
                             col = c25[1:nrow(simple_ct)])


## now trying to match with Seurat CBs
# Function to extract UMI and CB from the V12 string and return a dataframe with a fusion name
extractUMICB <- function(v12_string, fusion, prefix) {
  # Split the string by semicolons to get tags
  tokens <- unlist(strsplit(v12_string, ";"))
  # Extract the RN tag for the UMI values
  rn_tag <- tokens[grep("^RN=", tokens)]
  rn <- if (length(rn_tag) > 0) sub("^RN=", "", rn_tag) else NA
  # Extract the CB tag for the cell barcodes
  cb_tag <- tokens[grep("^CB=", tokens)]
  cb <- if (length(cb_tag) > 0) sub("^CB=", "", cb_tag) else NA
  # Split each by comma to get individual elements
  rn_values <- unlist(strsplit(rn, ","))
  cb_values <- unlist(strsplit(cb, ","))
  # Check if lengths match; if not, warn (here we assume they match or replicate the last value)
  if (length(rn_values) != length(cb_values)) {
    warning("Mismatch between number of UMIs and Cell Barcodes; check the V12 format!")
  }
  # Create a dataframe: each UMI is paired with its corresponding CB and the fusion name
  data.frame(UMI = rn_values, CB = cb_values, Fusion = fusion, Prefix = prefix, stringsAsFactors = FALSE)
}

# extract UMIs and CBs from the fusion count file:
umi_cb_list <- lapply(1:nrow(ct), function(i) extractUMICB(ct$V12[i], ct$fusion[i], ct$sample[i]) )
umi_cb_list <- do.call(rbind, umi_cb_list)

# create a count matrix for the fusions detected:
fusions <- umi_cb_list$Fusion %>% unlist() %>% na.omit() %>% unique() %>% sort()
if (length(unique(seu_cb$sepr)) == 1 && length(unique(seu_cb$sufx)) == 1) {
  umi_cb_list$seu_CB <- paste0(umi_cb_list$Prefix, unique(seu_cb$sepr), umi_cb_list$CB, unique(seu_cb$sufx))
} else {stop("there is more than 1 separator type and/or more than 1 suffix type in the naming standard of Seurat CBs")}
umi_cb_list <- split(data.table::setDT(umi_cb_list), by = "seu_CB")
fusion.matrix <- matrix(0, nrow = length(fusions), ncol = length(umi_cb_list), dimnames = list(fusions, names(umi_cb_list)))
for (i in 1:length(umi_cb_list)) {
  counts <- table(umi_cb_list[[i]]$Fusion)
  fusion.matrix[, i] <- counts[fusions]
}
fusion.matrix <- as.data.frame(t(fusion.matrix))
fusion.matrix <- fusion.matrix[rownames(fusion.matrix) %in% colnames(seu),]
cells <- data.frame(row.names = colnames(seu))
fusion.matrix<- merge(fusion.matrix, cells, by= "row.names", all=T)
rownames(fusion.matrix) <- fusion.matrix$Row.names
fusion.matrix$Row.names <- NULL
fusion.matrix <- fusion.matrix[order(rownames(fusion.matrix)),]
fusion.matrix[is.na(fusion.matrix)] <- 0
fusion.matrix <- fusion.matrix[,which(colSums(fusion.matrix)>0)]
fusion.matrix <- as.matrix(t(fusion.matrix))
fusion.matrix <- Matrix::Matrix(fusion.matrix,sparse = T)
FUSION <- CreateAssayObject(counts = fusion.matrix)
seu@assays$FUSION <- FUSION

## Visualize
DefaultAssay(seu) <- "FUSION"
FeaturePlot_scCustom(seu, row.names(seu)[7], pt.size = 0.1)
FeaturePlot_scCustom(seu, 
                     split.by = "geno", 
                     "KMT2A-MLLT3", pt.size = 0.1)#+thm

# ## Save your object
# saveRDS(seu, file.path(CDS_DIR, "AML401_Seurat.RDS"))


```
